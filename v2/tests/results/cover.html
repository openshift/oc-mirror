
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>additional: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/lmzuccarelli/golang-oci-mirror/pkg/additional/collector.go (52.2%)</option>
				
				<option value="file1">github.com/lmzuccarelli/golang-oci-mirror/pkg/batch/worker.go (61.3%)</option>
				
				<option value="file2">github.com/lmzuccarelli/golang-oci-mirror/pkg/cli/executor.go (50.7%)</option>
				
				<option value="file3">github.com/lmzuccarelli/golang-oci-mirror/pkg/config/defaults.go (100.0%)</option>
				
				<option value="file4">github.com/lmzuccarelli/golang-oci-mirror/pkg/config/load.go (81.2%)</option>
				
				<option value="file5">github.com/lmzuccarelli/golang-oci-mirror/pkg/config/validate.go (95.0%)</option>
				
				<option value="file6">github.com/lmzuccarelli/golang-oci-mirror/pkg/log/logger.go (83.3%)</option>
				
				<option value="file7">github.com/lmzuccarelli/golang-oci-mirror/pkg/manifest/oci-manifest.go (80.6%)</option>
				
				<option value="file8">github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror/mirror.go (51.6%)</option>
				
				<option value="file9">github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror/options.go (60.4%)</option>
				
				<option value="file10">github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror/unshare_linux.go (30.8%)</option>
				
				<option value="file11">github.com/lmzuccarelli/golang-oci-mirror/pkg/operator/collector.go (69.2%)</option>
				
				<option value="file12">github.com/lmzuccarelli/golang-oci-mirror/pkg/release/cincinnati.go (78.1%)</option>
				
				<option value="file13">github.com/lmzuccarelli/golang-oci-mirror/pkg/release/client.go (84.6%)</option>
				
				<option value="file14">github.com/lmzuccarelli/golang-oci-mirror/pkg/release/collector.go (66.2%)</option>
				
				<option value="file15">github.com/lmzuccarelli/golang-oci-mirror/pkg/release/core-cincinnati.go (83.3%)</option>
				
				<option value="file16">github.com/lmzuccarelli/golang-oci-mirror/pkg/release/find.go (95.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package additional

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha3"
        clog "github.com/lmzuccarelli/golang-oci-mirror/pkg/log"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/manifest"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror"
)

const (
        indexJson               string = "index.json"
        operatorImageExtractDir string = "hold-operator"
        workingDir              string = "working-dir/"
        dockerProtocol          string = "docker://"
        ociProtocol             string = "oci://"
        ociProtocolTrimmed      string = "oci:"
        additionalImagesDir     string = "additional-images"
        blobsDir                string = "/blobs/sha256/"
        diskToMirror            string = "diskToMirror"
        mirrorToDisk            string = "mirrorToDisk"
        errMsg                  string = "[AdditionalImagesCollector] %v "
        logsFile                string = "logs/additional-images.log"
)

type CollectorInterface interface {
        AdditionalImagesCollector(ctx context.Context) ([]string, error)
}

func New(log clog.PluggableLoggerInterface,
        config v1alpha2.ImageSetConfiguration,
        opts mirror.CopyOptions,
        mirror mirror.MirrorInterface,
        manifest manifest.ManifestInterface,
) CollectorInterface <span class="cov0" title="0">{
        return &amp;Collector{Log: log, Config: config, Opts: opts, Mirror: mirror, Manifest: manifest}
}</span>

type Collector struct {
        Log      clog.PluggableLoggerInterface
        Mirror   mirror.MirrorInterface
        Manifest manifest.ManifestInterface
        Config   v1alpha2.ImageSetConfiguration
        Opts     mirror.CopyOptions
}

// AdditionalImagesCollector - this looks into the additional images field
// taking into account the mode we are in (mirrorToDisk, diskToMirror)
// the image is downloaded in oci format
func (o *Collector) AdditionalImagesCollector(ctx context.Context) ([]string, error) <span class="cov8" title="1">{

        var allImages []string
        if !strings.Contains(o.Opts.Destination, ociProtocol) &amp;&amp; !strings.Contains(o.Opts.Destination, dockerProtocol) </span><span class="cov0" title="0">{
                return []string{}, fmt.Errorf(errMsg, "destination must use oci:// or docker:// prefix")
        }</span>

        <span class="cov8" title="1">if o.Opts.Mode == mirrorToDisk </span><span class="cov8" title="1">{
                for _, img := range o.Config.ImageSetConfigurationSpec.Mirror.AdditionalImages </span><span class="cov8" title="1">{
                        irs, err := customImageParser(img.Name)
                        o.Log.Debug("%v", irs)
                        if err != nil </span><span class="cov0" title="0">{
                                return []string{}, nil
                        }</span>
                        <span class="cov8" title="1">src := dockerProtocol + img.Name
                        dest := ociProtocolTrimmed + o.Opts.Global.Dir + "/" + additionalImagesDir + "/" + irs.Component
                        o.Log.Trace("source %s", src)
                        o.Log.Trace("destination %s", dest)
                        allImages = append(allImages, src+"*"+dest)</span>
                }
        }

        <span class="cov8" title="1">if o.Opts.Mode == diskToMirror </span><span class="cov0" title="0">{
                regex, e := regexp.Compile(indexJson)
                if e != nil </span><span class="cov0" title="0">{
                        o.Log.Error("%v", e)
                }</span>
                <span class="cov0" title="0">e = filepath.Walk(workingDir+"/"+o.Opts.Global.From+"/"+additionalImagesDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err == nil &amp;&amp; regex.MatchString(info.Name()) </span><span class="cov0" title="0">{
                                ns := strings.Split(filepath.Dir(path), additionalImagesDir)
                                if len(ns) == 0 </span><span class="cov0" title="0">{
                                        return fmt.Errorf(errMsg+"%s", "no directory found for additional-images ", path)
                                }</span> else<span class="cov0" title="0"> {
                                        name := strings.Split(ns[1], "/")
                                        if len(name) != 2 </span><span class="cov0" title="0">{
                                                return fmt.Errorf(errMsg+" %s ", "additional images name and related compents are incorrect", name)
                                        }</span>
                                        <span class="cov0" title="0">src := strings.Trim(ociProtocol, "/") + ns[0] + additionalImagesDir + "/" + name[1]
                                        dest := o.Opts.Destination + "/" + name[1]
                                        allImages = append(allImages, src+"*"+dest)</span>
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if e != nil </span><span class="cov0" title="0">{
                        return []string{}, e
                }</span>
        }
        <span class="cov8" title="1">return allImages, nil</span>
}

// customImageParser - simple image string parser
func customImageParser(image string) (*v1alpha3.ImageRefSchema, error) <span class="cov8" title="1">{
        var irs *v1alpha3.ImageRefSchema
        var component string
        parts := strings.Split(image, "/")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return irs, fmt.Errorf("[customImageParser] image url seems to be wrong %s ", image)
        }</span>
        <span class="cov8" title="1">component = parts[2]
        if strings.Contains(parts[2], "@") </span><span class="cov0" title="0">{
                component = strings.Split(parts[2], "@")[0]
        }</span>
        <span class="cov8" title="1">if strings.Contains(parts[2], ":") </span><span class="cov8" title="1">{
                component = strings.Split(parts[2], ":")[0]
        }</span>
        <span class="cov8" title="1">irs = &amp;v1alpha3.ImageRefSchema{Repository: parts[0], Namespace: parts[1], Component: component}
        return irs, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package batch

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "strconv"
        "strings"
        "sync"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha3"
        clog "github.com/lmzuccarelli/golang-oci-mirror/pkg/log"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/manifest"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror"
)

const (
        BATCH_SIZE int    = 8
        logFile    string = "logs/worker-{batch}.log"
)

type BatchInterface interface {
        Worker(ctx context.Context, images []string, opts mirror.CopyOptions) error
}

func New(log clog.PluggableLoggerInterface,
        mirror mirror.MirrorInterface,
        manifest manifest.ManifestInterface,
) BatchInterface <span class="cov8" title="1">{
        return &amp;Batch{Log: log, Mirror: mirror, Manifest: manifest}
}</span>

type Batch struct {
        Log      clog.PluggableLoggerInterface
        Mirror   mirror.MirrorInterface
        Manifest manifest.ManifestInterface
}

type BatchSchema struct {
        Writer     io.Writer
        CopyImages []v1alpha3.RelatedImage
        Items      int
        Count      int
        BatchSize  int
        BatchIndex int
        Remainder  int
}

// Worker - the main batch processor
func (o *Batch) Worker(ctx context.Context, images []string, opts mirror.CopyOptions) error <span class="cov8" title="1">{

        var errArray []error
        var wg sync.WaitGroup
        var err error

        var b *BatchSchema
        imgs := len(images)
        if imgs &lt; BATCH_SIZE </span><span class="cov8" title="1">{
                b = &amp;BatchSchema{Items: imgs, Count: 1, BatchSize: imgs, BatchIndex: 0, Remainder: 0}
        }</span> else<span class="cov0" title="0"> {
                b = &amp;BatchSchema{Items: imgs, Count: (imgs / BATCH_SIZE), BatchSize: BATCH_SIZE, Remainder: (imgs % BATCH_SIZE)}
        }</span>

        <span class="cov8" title="1">o.Log.Info("images to mirror %d ", b.Items)
        o.Log.Info("batch count %d ", b.Count)
        o.Log.Info("batch index %d ", b.BatchIndex)
        o.Log.Info("batch size %d ", b.BatchSize)
        o.Log.Info("remainder size %d ", b.Remainder)

        f := make([]*os.File, b.Count)
        //f, err := make([]os.File)
        // prepare batching
        wg.Add(b.BatchSize)
        for i := 0; i &lt; b.Count; i++ </span><span class="cov8" title="1">{
                // create a log file for each batch
                f[i], err = os.Create(strings.Replace(logFile, "{batch}", strconv.Itoa(i), -1))
                if err != nil </span><span class="cov8" title="1">{
                        o.Log.Error("[Worker] %v", err)
                }</span>
                <span class="cov8" title="1">writer := bufio.NewWriter(f[i])
                o.Log.Info(fmt.Sprintf("starting batch %d ", i))
                for x := 0; x &lt; b.BatchSize; x++ </span><span class="cov8" title="1">{
                        index := (i * b.BatchSize) + x
                        hld := strings.Split(images[index], "*")
                        if len(hld) == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("the source and destination selector is missing")
                        }</span>
                        <span class="cov8" title="1">o.Log.Debug("destination %s ", hld[1])
                        go func(ctx context.Context, src, dest string, opts *mirror.CopyOptions, writer bufio.Writer) </span><span class="cov8" title="1">{
                                defer wg.Done()
                                err := o.Mirror.Run(ctx, src, dest, "copy", opts, writer)
                                if err != nil </span><span class="cov0" title="0">{
                                        errArray = append(errArray, err)
                                }</span>
                        }(ctx, hld[0], hld[1], &amp;opts, *writer)
                }
                <span class="cov8" title="1">wg.Wait()
                // rather than use defer Close we intentianally close the log files
                for _, f := range f </span><span class="cov8" title="1">{
                        f.Close()
                }</span>
                <span class="cov8" title="1">o.Log.Info("completed batch %d", i)
                if b.Count &gt; 1 </span><span class="cov0" title="0">{
                        wg.Add(BATCH_SIZE)
                }</span>
                <span class="cov8" title="1">if len(errArray) &gt; 0 </span><span class="cov0" title="0">{
                        for _, err := range errArray </span><span class="cov0" title="0">{
                                o.Log.Error("[Worker] errArray %v", err)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("[Worker] error in batch - refer to console logs")</span>
                }
        }
        <span class="cov8" title="1">if b.Remainder &gt; 0 </span><span class="cov0" title="0">{
                // one level of simple recursion
                i := b.Count * BATCH_SIZE
                o.Log.Info("executing remainder [batch size of 1]")
                err := o.Worker(ctx, images[i:], opts)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // output the logs to console
                <span class="cov0" title="0">if !opts.Global.Quiet </span><span class="cov0" title="0">{
                        consoleLogFromFile(o.Log)
                }</span>
                <span class="cov0" title="0">o.Log.Info("[Worker] successfully completed all batches")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// consoleLogFromFile
func consoleLogFromFile(log clog.PluggableLoggerInterface) <span class="cov0" title="0">{
        dir, _ := os.ReadDir("logs")
        for _, f := range dir </span><span class="cov0" title="0">{
                if strings.Contains(f.Name(), "worker") </span><span class="cov0" title="0">{
                        log.Debug("[batch] %s ", f.Name())
                        data, _ := os.ReadFile("logs/" + f.Name())
                        lines := strings.Split(string(data), "\n")
                        for _, s := range lines </span><span class="cov0" title="0">{
                                if len(s) &gt; 0 </span><span class="cov0" title="0">{
                                        // clean the line
                                        log.Debug("%s ", strings.ToLower(s))
                                }</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package services

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "k8s.io/kubectl/pkg/util/templates"

        "github.com/google/uuid"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/additional"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/batch"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/config"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/diff"
        clog "github.com/lmzuccarelli/golang-oci-mirror/pkg/log"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/manifest"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/operator"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/release"
        "github.com/spf13/cobra"
)

const (
        dockerProtocol  string = "docker://"
        ociProtocol     string = "oci://"
        diskToMirror    string = "diskToMirror"
        mirrorToDisk    string = "mirrorToDisk"
        releaseImageDir string = "release-images"
)

var (
        mirrorlongDesc = templates.LongDesc(
                ` 
                Create and publish user-configured mirrors with a declarative configuration input.
                used for authenticating to the registries. 

                The podman location for credentials is also supported as a secondary location.

                1. Destination prefix is docker:// - The current working directory will be used.
                2. Destination prefix is oci:// - The destination directory specified will be used.

                `,
        )
        mirrorExamples = templates.Examples(
                `
                # Mirror to a directory
                oc-mirror oci:mirror --config mirror-config.yaml
                `,
        )
)

const (
        logsDir                 string = "logs/"
        workingDir              string = "working-dir/"
        additionalImages        string = "additional-images"
        releaseImageExtractDir  string = "hold-release"
        operatorImageExtractDir string = "hold-operator"
)

type ExecutorSchema struct {
        Log              clog.PluggableLoggerInterface
        Config           v1alpha2.ImageSetConfiguration
        MetaData         diff.SequenceSchema
        Opts             mirror.CopyOptions
        Operator         operator.CollectorInterface
        Release          release.CollectorInterface
        AdditionalImages additional.CollectorInterface
        Mirror           mirror.MirrorInterface
        Manifest         manifest.ManifestInterface
        Batch            batch.BatchInterface
        Diff             diff.DiffInterface
}

// NewMirrorCmd - cobra entry point
func NewMirrorCmd(log clog.PluggableLoggerInterface) *cobra.Command <span class="cov8" title="1">{

        global := &amp;mirror.GlobalOptions{
                TlsVerify:      false,
                InsecurePolicy: true,
        }

        flagSharedOpts, sharedOpts := mirror.SharedImageFlags()
        flagDepTLS, deprecatedTLSVerifyOpt := mirror.DeprecatedTLSVerifyFlags()
        flagSrcOpts, srcOpts := mirror.ImageFlags(global, sharedOpts, deprecatedTLSVerifyOpt, "src-", "screds")
        flagDestOpts, destOpts := mirror.ImageDestFlags(global, sharedOpts, deprecatedTLSVerifyOpt, "dest-", "dcreds")
        flagRetryOpts, retryOpts := mirror.RetryFlags()

        opts := mirror.CopyOptions{
                Global:              global,
                DeprecatedTLSVerify: deprecatedTLSVerifyOpt,
                SrcImage:            srcOpts,
                DestImage:           destOpts,
                RetryOpts:           retryOpts,
                Dev:                 false,
        }

        ex := &amp;ExecutorSchema{
                Log:  log,
                Opts: opts,
        }

        cmd := &amp;cobra.Command{
                Use:           fmt.Sprintf("%v &lt;destination type&gt;:&lt;destination location&gt;", filepath.Base(os.Args[0])),
                Version:       "v0.0.1",
                Short:         "Manage mirrors per user configuration",
                Long:          mirrorlongDesc,
                Example:       mirrorExamples,
                Args:          cobra.MinimumNArgs(1),
                SilenceErrors: false,
                SilenceUsage:  false,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        err := ex.Validate(args)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("%v ", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">ex.Complete(args)

                        err = ex.Run(cmd, args)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("%v ", err)
                                os.Exit(1)
                        }</span>
                },
        }

        <span class="cov8" title="1">cmd.PersistentFlags().StringVar(&amp;opts.Global.ConfigPath, "config", "", "Path to imageset configuration file")
        cmd.Flags().StringVar(&amp;opts.Global.LogLevel, "loglevel", "info", "Log level one of (info, debug, trace, error)")
        cmd.Flags().StringVar(&amp;opts.Global.Dir, "dir", "working-dir", "Assets directory")
        cmd.Flags().StringVar(&amp;opts.Global.From, "from", "", "directory used when doing the oci: (mirrorToDisk) mode")
        cmd.Flags().BoolVarP(&amp;opts.Global.Quiet, "quiet", "q", false, "enable detailed logging when copying images")
        cmd.Flags().BoolVarP(&amp;opts.Global.Force, "force", "f", false, "force the copy and mirror functionality")
        cmd.Flags().AddFlagSet(&amp;flagSharedOpts)
        cmd.Flags().AddFlagSet(&amp;flagRetryOpts)
        cmd.Flags().AddFlagSet(&amp;flagDepTLS)
        cmd.Flags().AddFlagSet(&amp;flagSrcOpts)
        cmd.Flags().AddFlagSet(&amp;flagDestOpts)
        return cmd</span>
}

// Run - start the mirror functionality
func (o *ExecutorSchema) Run(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{

        // clean up logs directory
        os.RemoveAll(logsDir)
        // ensure working dir exists
        err := os.MkdirAll(workingDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(" %v ", err)
                return err
        }</span>

        // create logs directory
        <span class="cov8" title="1">err = os.MkdirAll(logsDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(" %v ", err)
                return err
        }</span>

        // create release cache dir
        <span class="cov8" title="1">o.Log.Trace("creating release cache directory %s ", o.Opts.Global.Dir+"/"+releaseImageExtractDir)
        err = os.MkdirAll(o.Opts.Global.Dir+"/"+releaseImageExtractDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(" %v ", err)
                return err
        }</span>

        // create operator cache dir
        <span class="cov8" title="1">o.Log.Trace("creating operator cache directory %s ", o.Opts.Global.Dir+"/"+operatorImageExtractDir)
        err = os.MkdirAll(o.Opts.Global.Dir+"/"+operatorImageExtractDir, 0755)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error(" %v ", err)
                return err
        }</span>

        <span class="cov8" title="1">var allRelatedImages []string

        // check if we need to copy or mirror
        // check if there is a change if so then continue as normal else
        // report that there is nothing to do (all up to date)
        _, prevCfg, err := o.Diff.GetAllMetadata(o.Opts.Global.Dir)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error("%v", err)
        }</span>
        <span class="cov8" title="1">res, err := o.Diff.CheckDiff(prevCfg)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error("%v", err)
        }</span>

        // check if there has been a change in the imagesetconfig
        // between a copy and mirror - it should not be changed
        <span class="cov8" title="1">if o.Opts.Mode == diskToMirror &amp;&amp; res &amp;&amp; !o.Opts.Global.Force </span><span class="cov0" title="0">{
                return fmt.Errorf("imagesetconfig should not be changed (from copy)")
        }</span>

        <span class="cov8" title="1">if !res &amp;&amp; !o.Opts.Global.Force </span><span class="cov0" title="0">{
                o.Log.Info("no change detected for copy and mirror")
                return nil
        }</span>

        // do releases
        <span class="cov8" title="1">imgs, err := o.Release.ReleaseImageCollector(cmd.Context())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">o.Log.Info("total release images to copy %d ", len(imgs))
        o.Opts.ImageType = "release"
        allRelatedImages = mergeImages(allRelatedImages, imgs)

        // do operators
        imgs, err = o.Operator.OperatorImageCollector(cmd.Context())
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">o.Log.Info("total operator images to copy %d ", len(imgs))
        o.Opts.ImageType = "operator"
        allRelatedImages = mergeImages(allRelatedImages, imgs)

        // do additionalImages
        imgs, err = o.AdditionalImages.AdditionalImagesCollector(cmd.Context())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">o.Log.Info("total additional images to copy %d ", len(imgs))
        allRelatedImages = mergeImages(allRelatedImages, imgs)

        //call the batch worker
        err = o.Batch.Worker(cmd.Context(), allRelatedImages, o.Opts)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // only execute if mode is diskToMirror
        <span class="cov8" title="1">err = o.Diff.DeleteImages(cmd.Context())
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error("%v", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Complete - do the final setup of modules
func (o *ExecutorSchema) Complete(args []string) <span class="cov0" title="0">{
        // override log level
        o.Log.Level(o.Opts.Global.LogLevel)
        o.Log.Debug("imagesetconfig file %s ", o.Opts.Global.ConfigPath)
        // read the ImageSetConfiguration
        cfg, err := config.ReadConfig(o.Opts.Global.ConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                o.Log.Error("imagesetconfig %v ", err)
        }</span>
        <span class="cov0" title="0">o.Log.Trace("imagesetconfig : %v ", cfg)

        // update all dependant modules
        mc := mirror.NewMirrorCopy()
        md := mirror.NewMirrorDelete()
        o.Manifest = manifest.New(o.Log)
        o.Mirror = mirror.New(mc, md)
        o.Config = cfg
        o.Batch = batch.New(o.Log, o.Mirror, o.Manifest)

        // logic to check mode
        var dest string
        if strings.Contains(args[0], ociProtocol) </span><span class="cov0" title="0">{
                o.Opts.Mode = mirrorToDisk
                dest = workingDir + strings.Split(args[0], ociProtocol)[1]
                o.Log.Debug("destination %s ", dest)
        }</span> else<span class="cov0" title="0"> if strings.Contains(args[0], dockerProtocol) </span><span class="cov0" title="0">{
                o.Opts.Mode = diskToMirror
                dest = o.Opts.Global.From
                o.Log.Debug("destination %s ", dest)
        }</span>
        <span class="cov0" title="0">o.Opts.Destination = args[0]
        o.Opts.Global.Dir = dest
        o.Log.Info("mode %s ", o.Opts.Mode)

        client, _ := release.NewOCPClient(uuid.New())
        cn := release.NewCincinnati(o.Log, &amp;o.Config, &amp;o.Opts, client, false)
        o.Release = release.New(o.Log, o.Config, o.Opts, o.Mirror, o.Manifest, cn)
        o.Operator = operator.New(o.Log, o.Config, o.Opts, o.Mirror, o.Manifest)
        o.AdditionalImages = additional.New(o.Log, o.Config, o.Opts, o.Mirror, o.Manifest)
        o.Diff = diff.New(o.Log, o.Config, o.Opts, o.Mirror)

        metadata, _, err := o.Diff.GetAllMetadata(dest)
        if err != nil </span><span class="cov0" title="0">{
                // if no previous imagesetconfig was found create new one
                item := []diff.Item{
                        {
                                Value:       0,
                                Current:     true,
                                Timestamp:   time.Now().Unix(),
                                Destination: dest,
                        },
                }
                seq := diff.Sequence{Item: item}
                metadata = diff.SequenceSchema{Title: "golang-oci-mirror", Owner: "CFE-EAMA", Sequence: seq}
                o.Log.Info("added new metadata %v ", metadata)
                err := o.Diff.WriteMetadata(o.Opts.Global.ConfigPath, dest, metadata, o.Config)
                if err != nil </span><span class="cov0" title="0">{
                        o.Log.Error("%v", err)
                }</span>
        }
        <span class="cov0" title="0">o.MetaData = metadata
        o.Log.Info("metadata %v ", metadata)</span>
}

// Validate - cobra validation
func (o *ExecutorSchema) Validate(dest []string) error <span class="cov8" title="1">{
        if len(o.Opts.Global.ConfigPath) == 0 &amp;&amp; strings.Contains(dest[0], ociProtocol) </span><span class="cov0" title="0">{
                return fmt.Errorf("use the --config flag when using oci: protocol")
        }</span>
        <span class="cov8" title="1">if len(o.Opts.Global.From) == 0 &amp;&amp; strings.Contains(dest[0], dockerProtocol) </span><span class="cov0" title="0">{
                return fmt.Errorf("use the --from flag when using docker: protocol")
        }</span>
        <span class="cov8" title="1">if strings.Contains(dest[0], ociProtocol) || strings.Contains(dest[0], dockerProtocol) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return fmt.Errorf("destination must have either oci:// or docker:// protocol prefixes")
        }</span>
}

// mergeImages - simple function to append releated images
// nolint
func mergeImages(base, in []string) []string <span class="cov8" title="1">{
        for _, img := range in </span><span class="cov8" title="1">{
                base = append(base, img)
        }</span>
        <span class="cov8" title="1">return base</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
)

// Complete set default values in the ImageSetConfiguration
// when applicable
func Complete(cfg *v1alpha2.ImageSetConfiguration) <span class="cov8" title="1">{
        completeReleaseArchitectures(cfg)
}</span>

func completeReleaseArchitectures(cfg *v1alpha2.ImageSetConfiguration) <span class="cov8" title="1">{
        if len(cfg.Mirror.Platform.Channels) != 0 &amp;&amp; len(cfg.Mirror.Platform.Architectures) == 0 </span><span class="cov8" title="1">{
                cfg.Mirror.Platform.Architectures = []string{v1alpha2.DefaultPlatformArchitecture}
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "bytes"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "sigs.k8s.io/yaml"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
)

// TODO(estroz): create interface scheme such that configuration and metadata
// versions do not matter to the caller.
// See https://github.com/kubernetes-sigs/controller-runtime/blob/master/pkg/config/config.go

// ReadConfig opens an imageset configuration file at the given path
// and loads it into a v1alpha2.ImageSetConfiguration instance for processing and validation.
func ReadConfig(configPath string) (c v1alpha2.ImageSetConfiguration, err error) <span class="cov8" title="1">{

        data, err := os.ReadFile(filepath.Clean(configPath))
        if err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>
        <span class="cov8" title="1">typeMeta, err := getTypeMeta(data)

        if err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov8" title="1">switch typeMeta.GroupVersionKind() </span>{
        case v1alpha2.GroupVersion.WithKind(v1alpha2.ImageSetConfigurationKind):<span class="cov8" title="1">
                c, err = LoadConfig(data)
                if err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>
        default:<span class="cov0" title="0">
                return c, fmt.Errorf("config GVK not recognized: %s", typeMeta.GroupVersionKind())</span>
        }

        <span class="cov8" title="1">Complete(&amp;c)

        return c, Validate(&amp;c)</span>
}

// LoadConfig loads data into a v1alpha2.ImageSetConfiguration instance
func LoadConfig(data []byte) (c v1alpha2.ImageSetConfiguration, err error) <span class="cov8" title="1">{

        gvk := v1alpha2.GroupVersion.WithKind(v1alpha2.ImageSetConfigurationKind)

        if data, err = yaml.YAMLToJSON(data); err != nil </span><span class="cov0" title="0">{
                return c, fmt.Errorf("yaml to json %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;c); err != nil </span><span class="cov8" title="1">{
                return c, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">c.SetGroupVersionKind(gvk)

        return c, nil</span>
}

// LoadMetadata loads data into a v1alpha2.Metadata instance
func LoadMetadata(data []byte) (m v1alpha2.Metadata, err error) <span class="cov8" title="1">{

        gvk := v1alpha2.GroupVersion.WithKind(v1alpha2.MetadataKind)

        dec := json.NewDecoder(bytes.NewBuffer(data))
        dec.DisallowUnknownFields()
        if err := dec.Decode(&amp;m); err != nil </span><span class="cov8" title="1">{
                return m, fmt.Errorf("decode %s: %v", gvk, err)
        }</span>

        <span class="cov8" title="1">m.SetGroupVersionKind(gvk)

        return m, nil</span>
}

func getTypeMeta(data []byte) (typeMeta metav1.TypeMeta, err error) <span class="cov8" title="1">{
        if err := yaml.Unmarshal(data, &amp;typeMeta); err != nil </span><span class="cov0" title="0">{
                return typeMeta, fmt.Errorf("get type meta: %v", err)
        }</span>
        <span class="cov8" title="1">return typeMeta, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package config

import (
        "fmt"

        utilerrors "k8s.io/apimachinery/pkg/util/errors"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
)

type validationFunc func(cfg *v1alpha2.ImageSetConfiguration) error

var validationChecks = []validationFunc{validateOperatorOptions, validateReleaseChannels}

// Validate will check an ImagesetConfiguration for input errors.
func Validate(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        var errs []error
        for _, check := range validationChecks </span><span class="cov8" title="1">{
                if err := check(cfg); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, fmt.Errorf("invalid configuration: %v", err))
                }</span>
        }
        <span class="cov8" title="1">return utilerrors.NewAggregate(errs)</span>
}

func validateOperatorOptions(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        seen := map[string]bool{}
        for _, ctlg := range cfg.Mirror.Operators </span><span class="cov8" title="1">{
                ctlgName, err := ctlg.GetUniqueName()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if seen[ctlgName] </span><span class="cov8" title="1">{
                        return fmt.Errorf(
                                "catalog %q: duplicate found in configuration", ctlgName,
                        )
                }</span>
                <span class="cov8" title="1">seen[ctlgName] = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateReleaseChannels(cfg *v1alpha2.ImageSetConfiguration) error <span class="cov8" title="1">{
        seen := map[string]bool{}
        for _, channel := range cfg.Mirror.Platform.Channels </span><span class="cov8" title="1">{
                if seen[channel.Name] </span><span class="cov8" title="1">{
                        return fmt.Errorf(
                                "release channel %q: duplicate found in configuration", channel.Name,
                        )
                }</span>
                <span class="cov8" title="1">seen[channel.Name] = true</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package log

import (
        "fmt"

        "github.com/microlib/simple"
)

// PluggableLoggerInterface - allows us to use other logging systems
// as long as the interface implementation is adhered to
type PluggableLoggerInterface interface {
        Error(msg string, val ...interface{})
        Info(msg string, val ...interface{})
        Debug(msg string, val ...interface{})
        Trace(msg string, val ...interface{})
        Level(levele string)
}

// PluggableLogger
type PluggableLogger struct {
        Log *simple.Logger
}

// New - returns a new PluggableLogger instance
func New(level string) PluggableLoggerInterface <span class="cov8" title="1">{
        return &amp;PluggableLogger{Log: &amp;simple.Logger{Level: level}}
}</span>

// Error
func (c *PluggableLogger) Error(msg string, val ...interface{}) <span class="cov8" title="1">{
        c.Log.Error(fmt.Sprintf(msg, val...))
}</span>

// Info
func (c *PluggableLogger) Info(msg string, val ...interface{}) <span class="cov8" title="1">{
        c.Log.Info(fmt.Sprintf(msg, val...))
}</span>

// Debug
func (c *PluggableLogger) Debug(msg string, val ...interface{}) <span class="cov8" title="1">{
        c.Log.Debug(fmt.Sprintf(msg, val...))
}</span>

// Trace
func (c *PluggableLogger) Trace(msg string, val ...interface{}) <span class="cov8" title="1">{
        c.Log.Trace(fmt.Sprintf(msg, val...))
}</span>

// Level - ovveride log level
func (c *PluggableLogger) Level(level string) <span class="cov0" title="0">{
        c.Log.Level = level
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package manifest

import (
        "archive/tar"
        "compress/gzip"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/blang/semver/v4"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha3"
        clog "github.com/lmzuccarelli/golang-oci-mirror/pkg/log"
        "k8s.io/klog/v2"
)

const (
        index                   string = "index.json"
        catalogJson             string = "catalog.json"
        operatorImageExtractDir string = "hold-operator"
        errorSemver             string = " semver %v "
)

type ManifestInterface interface {
        GetImageIndex(dir string) (*v1alpha3.OCISchema, error)
        GetImageManifest(file string) (*v1alpha3.OCISchema, error)
        GetOperatorConfig(file string) (*v1alpha3.OperatorConfigSchema, error)
        GetRelatedImagesFromCatalog(filePath, label string) (map[string][]v1alpha3.RelatedImage, error)
        GetRelatedImagesFromCatalogByFilter(filePath, label string, op v1alpha2.Operator, mp map[string]v1alpha3.ISCPackage) (map[string][]v1alpha3.RelatedImage, error)
        ExtractLayersOCI(filePath, toPath, label string, oci *v1alpha3.OCISchema) error
        GetReleaseSchema(filePath string) ([]v1alpha3.RelatedImage, error)
}

type Manifest struct {
        Log clog.PluggableLoggerInterface
}

func New(log clog.PluggableLoggerInterface) ManifestInterface <span class="cov0" title="0">{
        return &amp;Manifest{Log: log}
}</span>

// GetImageIndex - used to get the oci index.json
func (o *Manifest) GetImageIndex(dir string) (*v1alpha3.OCISchema, error) <span class="cov8" title="1">{
        var oci *v1alpha3.OCISchema
        indx, err := os.ReadFile(dir + "/" + index)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(indx, &amp;oci)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return oci, nil</span>
}

// GetImageManifest used to ge the manifest in the oci blobs/sha254
// directory - found in index.json
func (o *Manifest) GetImageManifest(file string) (*v1alpha3.OCISchema, error) <span class="cov8" title="1">{
        var oci *v1alpha3.OCISchema
        manifest, err := os.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(manifest, &amp;oci)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return oci, nil</span>
}

// GetOperatorConfig used to parse the operator json
func (o *Manifest) GetOperatorConfig(file string) (*v1alpha3.OperatorConfigSchema, error) <span class="cov8" title="1">{
        var ocs *v1alpha3.OperatorConfigSchema
        manifest, err := os.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal(manifest, &amp;ocs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ocs, nil</span>
}

// operatorImageExtractDir + "/" + label
// GetRelatedImagesFromCatalog
func (o *Manifest) GetRelatedImagesFromCatalog(filePath, label string) (map[string][]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        files, err := os.ReadDir(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return relatedImages, err
        }</span>
        <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                // the catalog.json - does not really conform to json standards
                // this needs some thorough testing
                olm, err := readOperatorCatalog(filePath + "/" + file.Name())
                if err != nil </span><span class="cov0" title="0">{
                        return relatedImages, err
                }</span>
                <span class="cov8" title="1">ri, err := getRelatedImageByDefaultChannel(o.Log, olm)
                if err != nil </span><span class="cov0" title="0">{
                        return relatedImages, err
                }</span>
                // append to relatedImages map
                <span class="cov8" title="1">for k, v := range ri </span><span class="cov8" title="1">{
                        relatedImages[k] = v
                }</span>
        }
        <span class="cov8" title="1">return relatedImages, nil</span>
}

// GetRelatedImagesFromCatalogByFilter
func (o *Manifest) GetRelatedImagesFromCatalogByFilter(filePath, label string, op v1alpha2.Operator, mp map[string]v1alpha3.ISCPackage) (map[string][]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        for _, pkg := range op.Packages </span><span class="cov8" title="1">{
                // the catalog.json - does not really conform to json standards
                // this needs some thorough testing
                olm, err := readOperatorCatalog(filePath + "/" + label + "/" + pkg.Name)
                if err != nil </span><span class="cov0" title="0">{
                        return relatedImages, err
                }</span>

                <span class="cov8" title="1">ri, err := getRelatedImageByFilter(o.Log, olm, mp[pkg.Name])
                if err != nil </span><span class="cov0" title="0">{
                        return relatedImages, err
                }</span>
                // append to reletedImages map
                <span class="cov8" title="1">for k, v := range ri </span><span class="cov8" title="1">{
                        relatedImages[k] = v
                }</span>
                <span class="cov8" title="1">o.Log.Trace("related images %v", relatedImages)</span>
        }
        <span class="cov8" title="1">return relatedImages, nil</span>
}

// ExtractLayersOCI
func (o *Manifest) ExtractLayersOCI(fromPath, toPath, label string, oci *v1alpha3.OCISchema) error <span class="cov8" title="1">{
        for _, blob := range oci.Layers </span><span class="cov8" title="1">{
                if !strings.Contains(blob.Digest, "sha256") </span><span class="cov0" title="0">{
                        return fmt.Errorf("the digest format is not correct %s ", blob.Digest)
                }</span>
                <span class="cov8" title="1">f, err := os.Open(fromPath + "/" + strings.Split(blob.Digest, ":")[1])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">err = untar(f, toPath, label)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// GetReleaseSchema
func (o *Manifest) GetReleaseSchema(filePath string) ([]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        var release = v1alpha3.ReleaseSchema{}

        file, _ := os.ReadFile(filePath)
        err := json.Unmarshal([]byte(file), &amp;release)
        if err != nil </span><span class="cov0" title="0">{
                return []v1alpha3.RelatedImage{}, err
        }</span>

        <span class="cov8" title="1">var allImages []v1alpha3.RelatedImage
        for _, item := range release.Spec.Tags </span><span class="cov8" title="1">{
                allImages = append(allImages, v1alpha3.RelatedImage{Image: item.From.Name, Name: item.Name})
        }</span>
        <span class="cov8" title="1">return allImages, nil</span>
}

// UntarLayers simple function that untars the image layers
func untar(gzipStream io.Reader, path string, cfgDirName string) error <span class="cov8" title="1">{
        //Remove any separators in cfgDirName as received from the label
        cfgDirName = strings.TrimSuffix(cfgDirName, "/")
        cfgDirName = strings.TrimPrefix(cfgDirName, "/")
        uncompressedStream, err := gzip.NewReader(gzipStream)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("untar: gzipStream - %w", err)
        }</span>

        <span class="cov8" title="1">tarReader := tar.NewReader(uncompressedStream)
        for </span><span class="cov8" title="1">{
                header, err := tarReader.Next()

                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("untar: Next() failed: %s", err.Error())
                }</span>

                <span class="cov8" title="1">if strings.Contains(header.Name, cfgDirName) </span><span class="cov8" title="1">{
                        switch header.Typeflag </span>{
                        case tar.TypeDir:<span class="cov8" title="1">
                                if header.Name != "./" </span><span class="cov8" title="1">{
                                        if err := os.MkdirAll(path+"/"+header.Name, 0755); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("untar: Mkdir() failed: %v", err)
                                        }</span>
                                }
                        case tar.TypeReg:<span class="cov8" title="1">
                                outFile, err := os.Create(path + "/" + header.Name)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("untar: Create() failed: %v", err)
                                }</span>
                                <span class="cov8" title="1">if _, err := io.Copy(outFile, tarReader); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("untar: Copy() failed: %v", err)
                                }</span>
                                <span class="cov8" title="1">outFile.Close()</span>

                        default:<span class="cov0" title="0">
                                // just ignore errors as we are only interested in the FB configs layer
                                klog.Warningf("untar: unknown type: %v in %s", header.Typeflag, header.Name)</span>
                        }
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// readOperatorCatalog - simple function tha treads the specific catalog.json file
// and unmarshals it to DeclarativeConfig struct
func readOperatorCatalog(path string) ([]v1alpha3.DeclarativeConfig, error) <span class="cov8" title="1">{
        // the catalog.json - dos not really conform to json standards
        // this needs some thorough testing
        // operatorImageExtractDir + "/" + label + "/" + name + "/" + catalogJson
        var olm []v1alpha3.DeclarativeConfig
        data, err := os.ReadFile(path + "/" + catalogJson)
        if err != nil </span><span class="cov0" title="0">{
                return []v1alpha3.DeclarativeConfig{}, err
        }</span>
        <span class="cov8" title="1">tmp := strings.NewReplacer(" ", "").Replace(string(data))
        updatedJson := "[" + strings.ReplaceAll(tmp, "}\n{", "},{") + "]"
        err = json.Unmarshal([]byte(updatedJson), &amp;olm)
        if err != nil </span><span class="cov0" title="0">{
                return []v1alpha3.DeclarativeConfig{}, err
        }</span>
        <span class="cov8" title="1">return olm, nil</span>
}

// getRelatedImageByDefaultChannel - get the DeclarativeConfig for the default channel
// it returns the HEAD (latest version of the bundles relatedImages)
func getRelatedImageByDefaultChannel(log clog.PluggableLoggerInterface, olm []v1alpha3.DeclarativeConfig) (map[string][]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        // relevant variables
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        bundles := make(map[string]bool)
        var defaultChannel string

        // iterate through the catalog objects
        for i, obj := range olm </span><span class="cov8" title="1">{
                switch </span>{
                case obj.Schema == "olm.channel":<span class="cov8" title="1">
                        if defaultChannel == obj.Name </span><span class="cov8" title="1">{
                                log.Debug("found channel : %v", obj)
                                log.Debug("bundle image to use : %v", obj.Entries[0].Name)
                                name, err := semverFindMax(obj.Entries)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error(errorSemver, err)
                                }</span>
                                <span class="cov8" title="1">bundles[name] = true</span>
                        }
                case obj.Schema == "olm.bundle":<span class="cov8" title="1">
                        if bundles[obj.Name] </span><span class="cov8" title="1">{
                                log.Debug("config bundle: %d %v", i, obj.Name)
                                log.Trace("config relatedImages: %d %v", i, obj.RelatedImages)
                                relatedImages[obj.Name] = obj.RelatedImages
                        }</span>
                case obj.Schema == "olm.package":<span class="cov8" title="1">
                        log.Debug("Config package: %v", obj.Name)
                        defaultChannel = obj.DefaultChannel</span>
                }
        }
        <span class="cov8" title="1">return relatedImages, nil</span>
}

// getRelatedImageByFilter - get the DeclarativeConfig for a specifc channel with
// min,max version if set
func getRelatedImageByFilter(log clog.PluggableLoggerInterface, olm []v1alpha3.DeclarativeConfig, pkg v1alpha3.ISCPackage) (map[string][]v1alpha3.RelatedImage, error) <span class="cov8" title="1">{
        // relevant variables
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        bundles := make(map[string]bool)
        // iterate through the catalog objects
        for i, obj := range olm </span><span class="cov8" title="1">{
                switch </span>{
                case obj.Schema == "olm.channel":<span class="cov8" title="1">
                        if len(pkg.Channel) &gt; 0 </span><span class="cov8" title="1">{
                                if pkg.Channel == obj.Name </span><span class="cov8" title="1">{
                                        log.Debug("found channel : %v", obj)
                                        name, err := semverFindRange(obj.Entries, pkg.MinVersion, pkg.MaxVersion)
                                        if err != nil </span><span class="cov0" title="0">{
                                                log.Error(errorSemver, err)
                                        }</span>
                                        <span class="cov8" title="1">for _, x := range name </span><span class="cov0" title="0">{
                                                bundles[x] = true
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                name, err := semverFindMax(obj.Entries)
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error(errorSemver, err)
                                }</span>
                                <span class="cov8" title="1">log.Debug("adding channel : %s", name)
                                bundles[name] = true</span>
                        }
                case obj.Schema == "olm.bundle":<span class="cov8" title="1">
                        if bundles[obj.Name] </span><span class="cov8" title="1">{
                                log.Debug("config bundle: %d %v", i, obj.Name)
                                log.Trace("config relatedImages: %d %v", i, obj.RelatedImages)
                                relatedImages[obj.Name] = obj.RelatedImages
                        }</span>
                case obj.Schema == "olm.package":<span class="cov8" title="1">
                        log.Debug("config package: %v", obj.Name)
                        bundles[obj.DefaultChannel] = true</span>
                }
        }
        <span class="cov8" title="1">return relatedImages, nil</span>
}

// semverFindMax - finds the max bundle version
func semverFindMax(entries []v1alpha3.ChannelEntry) (string, error) <span class="cov8" title="1">{
        var max semver.Version
        var index int
        for id, s := range entries </span><span class="cov8" title="1">{
                hld := strings.Split(s.Name, ".")
                // we are only interested in 1,2,3 positions
                if len(hld) &lt; 4 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("versioning of string is not correct %s ", s.Name)
                }</span>
                <span class="cov8" title="1">hld[1] = strings.Replace(hld[1], "v", "", -1)
                end := strings.Split(hld[3], "-")
                semStr := strings.Join([]string{hld[1], hld[2], end[0]}, ".")
                version, err := semver.Parse(semStr)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">if version.Compare(max) == 1 </span><span class="cov8" title="1">{
                        max = version
                        index = id
                }</span>
        }
        <span class="cov8" title="1">return entries[index].Name, nil</span>
}

// semverFindRange - finds the bundles between ranges version
func semverFindRange(entries []v1alpha3.ChannelEntry, min, max string) ([]string, error) <span class="cov8" title="1">{

        var minVersion semver.Version
        var maxVersion semver.Version
        var err error
        var results []string

        // parse the min max strings
        if len(min) &gt; 0 </span><span class="cov8" title="1">{
                minVersion, err = semver.Parse(min)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                minVersion, _ = semver.Parse("0.0.0")
        }</span>
        <span class="cov8" title="1">if len(max) &gt; 0 </span><span class="cov8" title="1">{
                maxVersion, err = semver.Parse(max)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                maxVersion, _ = semver.Parse("9.9.9")
        }</span>

        <span class="cov8" title="1">for _, s := range entries </span><span class="cov8" title="1">{
                hld := strings.Split(s.Name, ".")
                // we are only interested in 1,2,3 positions
                if len(hld) &lt; 4 </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf("versioning of string is not correct %s ", s.Name)
                }</span>
                <span class="cov8" title="1">hld[1] = strings.Replace(hld[1], "v", "", -1)
                end := strings.Split(hld[3], "-")
                semStr := strings.Join([]string{hld[1], hld[2], end[0]}, ".")
                version, err := semver.Parse(semStr)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, err
                }</span>
                <span class="cov8" title="1">if version.Compare(maxVersion) &lt;= 0 &amp;&amp; version.Compare(minVersion) &gt;= 1 </span><span class="cov0" title="0">{
                        results = append(results, s.Name)
                }</span>
        }
        <span class="cov8" title="1">return results, nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package mirror

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "os"
        "strconv"

        "github.com/containers/common/pkg/retry"
        "github.com/containers/image/manifest"
        "github.com/containers/image/v5/copy"
        "github.com/containers/image/v5/pkg/cli"
        "github.com/containers/image/v5/signature"
        "github.com/containers/image/v5/transports/alltransports"
        "github.com/containers/image/v5/types"
        "github.com/docker/distribution/reference"
)

const (
        mirrorToDisk = "mirrorToDisk"
        diskToMirror = "diskToMirror"
)

// MirrorInterface  used to mirror images with container/images (skopeo)
type MirrorInterface interface {
        Run(ctx context.Context, src, dest, mode string, opts *CopyOptions, stdout bufio.Writer) (retErr error)
}

type MirrorCopyInterface interface {
        CopyImage(ctx context.Context, pc *signature.PolicyContext, destRef, srcRef types.ImageReference, opts *copy.Options) ([]byte, error)
}

type MirrorDeleteInterface interface {
        DeleteImage(ctx context.Context, image string, opts *CopyOptions) error
}

// Mirror
type Mirror struct {
        mc   MirrorCopyInterface
        md   MirrorDeleteInterface
        Mode string
}

type MirrorCopy struct{}
type MirrorDelete struct{}

// New returns new Mirror instance
func New(mc MirrorCopyInterface, md MirrorDeleteInterface) MirrorInterface <span class="cov8" title="1">{
        return &amp;Mirror{mc: mc, md: md}
}</span>

func NewMirrorCopy() MirrorCopyInterface <span class="cov0" title="0">{
        return &amp;MirrorCopy{}
}</span>

func NewMirrorDelete() MirrorDeleteInterface <span class="cov0" title="0">{
        return &amp;MirrorDelete{}
}</span>

// Run - method to copy images from source to destination
func (o *Mirror) Run(ctx context.Context, src, dest, mode string, opts *CopyOptions, stdout bufio.Writer) (retErr error) <span class="cov8" title="1">{
        if mode == "delete" </span><span class="cov0" title="0">{
                return o.delete(ctx, src, opts)
        }</span>
        <span class="cov8" title="1">return o.copy(ctx, src, dest, opts, stdout)</span>
}

func (o *MirrorCopy) CopyImage(ctx context.Context, pc *signature.PolicyContext, destRef, srcRef types.ImageReference, co *copy.Options) ([]byte, error) <span class="cov0" title="0">{
        return copy.Image(ctx, pc, destRef, srcRef, co)
}</span>

func (o *MirrorDelete) DeleteImage(ctx context.Context, image string, co *CopyOptions) error <span class="cov0" title="0">{
        return nil
}</span>

// copy - copy images setup and execute
func (o *Mirror) copy(ctx context.Context, src, dest string, opts *CopyOptions, out bufio.Writer) (retErr error) <span class="cov8" title="1">{

        opts.DeprecatedTLSVerify.WarnIfUsed([]string{"--src-tls-verify", "--dest-tls-verify"})

        opts.RemoveSignatures, _ = strconv.ParseBool("true")

        if err := ReexecIfNecessaryForImages([]string{src, dest}...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">policyContext, err := opts.Global.GetPolicyContext()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error loading trust policy: %v", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err := policyContext.Destroy(); err != nil </span><span class="cov0" title="0">{
                        retErr = NoteCloseFailure(retErr, "tearing down policy context", err)
                }</span>
        }()

        <span class="cov8" title="1">srcRef, err := alltransports.ParseImageName(src)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid source name %s: %v", src, err)
        }</span>
        <span class="cov8" title="1">destRef, err := alltransports.ParseImageName(dest)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid destination name %s: %v", dest, err)
        }</span>

        <span class="cov8" title="1">sourceCtx, err := opts.SrcImage.NewSystemContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">destinationCtx, err := opts.DestImage.NewSystemContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var manifestType string
        if len(opts.Format) &gt; 0 </span><span class="cov8" title="1">{
                manifestType, err = ParseManifestFormat(opts.Format)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        /*
                for _, image := range opts.AdditionalTags {
                        ref, err := reference.ParseNormalizedNamed(image)
                        if err != nil {
                                return fmt.Errorf("error parsing additional-tag '%s': %v", image, err)
                        }
                        namedTagged, isNamedTagged := ref.(reference.NamedTagged)
                        if !isNamedTagged {
                                return fmt.Errorf("additional-tag '%s' must be a tagged reference", image)
                        }
                        destinationCtx.DockerArchiveAdditionalTags = append(destinationCtx.DockerArchiveAdditionalTags, namedTagged)
                }
        */

        <span class="cov8" title="1">ctx, cancel := opts.Global.CommandTimeoutContext()
        defer cancel()

        //if opts.Quiet {
        //        stdout = nil
        //}

        imageListSelection := copy.CopySystemImage
        if len(opts.MultiArch) &gt; 0 &amp;&amp; opts.All </span><span class="cov0" title="0">{
                return fmt.Errorf("Cannot use --all and --multi-arch flags together")
        }</span>

        <span class="cov8" title="1">if len(opts.MultiArch) &gt; 0 </span><span class="cov8" title="1">{
                imageListSelection, err = parseMultiArch(opts.MultiArch)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if opts.All </span><span class="cov0" title="0">{
                imageListSelection = copy.CopyAllImages
        }</span>

        <span class="cov8" title="1">if len(opts.EncryptionKeys) &gt; 0 &amp;&amp; len(opts.DecryptionKeys) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("--encryption-key and --decryption-key cannot be specified together")
        }</span>

        /*
                var encLayers *[]int
                var encConfig *encconfig.EncryptConfig
                var decConfig *encconfig.DecryptConfig

                if len(opts.EncryptLayer) &gt; 0 &amp;&amp; len(opts.EncryptionKeys) == 0 {
                        return fmt.Errorf("--encrypt-layer can only be used with --encryption-key")
                }

                if len(opts.EncryptionKeys) &gt; 0 {
                        // encryption
                        p := opts.EncryptLayer
                        encLayers = &amp;p
                        encryptionKeys := opts.EncryptionKeys
                        ecc, err := enchelpers.CreateCryptoConfig(encryptionKeys, []string{})
                        if err != nil {
                                return fmt.Errorf("Invalid encryption keys: %v", err)
                        }
                        cc := encconfig.CombineCryptoConfigs([]encconfig.CryptoConfig{ecc})
                        encConfig = cc.EncryptConfig
                }

                if len(opts.DecryptionKeys) &gt; 0 {
                        // decryption
                        decryptionKeys := opts.DecryptionKeys
                        dcc, err := enchelpers.CreateCryptoConfig([]string{}, decryptionKeys)
                        if err != nil {
                                return fmt.Errorf("Invalid decryption keys: %v", err)
                        }
                        cc := encconfig.CombineCryptoConfigs([]encconfig.CryptoConfig{dcc})
                        decConfig = cc.DecryptConfig
                }
        */

        // c/image/copy.Image does allow creating both simple signing and sigstore signatures simultaneously,
        // with independent passphrases, but that would make the CLI probably too confusing.
        // For now, use the passphrase with either, but only one of them.
        <span class="cov8" title="1">if opts.SignPassphraseFile != "" &amp;&amp; opts.SignByFingerprint != "" &amp;&amp; opts.SignBySigstorePrivateKey != "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Only one of --sign-by and sign-by-sigstore-private-key can be used with sign-passphrase-file")
        }</span>
        <span class="cov8" title="1">var passphrase string
        if opts.SignPassphraseFile != "" </span><span class="cov8" title="1">{
                p, err := cli.ReadPassphraseFile(opts.SignPassphraseFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">passphrase = p</span>
        }

        // opts.signByFingerprint triggers a GPG-agent passphrase prompt, possibly using a more secure channel,
        // so we usually shouldnt prompt ourselves if no passphrase was explicitly provided.
        <span class="cov8" title="1">var signIdentity reference.Named = nil
        if opts.SignIdentity != "" </span><span class="cov0" title="0">{
                signIdentity, err = reference.ParseNamed(opts.SignIdentity)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Could not parse --sign-identity: %v", err)
                }</span>
        }

        //opts.DigestFile = "test-digest"
        <span class="cov8" title="1">writer := io.Writer(&amp;out)

        co := &amp;copy.Options{
                RemoveSignatures:                 opts.RemoveSignatures,
                SignBy:                           opts.SignByFingerprint,
                SignPassphrase:                   passphrase,
                SignBySigstorePrivateKeyFile:     opts.SignBySigstorePrivateKey,
                SignSigstorePrivateKeyPassphrase: []byte(passphrase),
                SignIdentity:                     signIdentity,
                ReportWriter:                     writer,
                SourceCtx:                        sourceCtx,
                DestinationCtx:                   destinationCtx,
                ForceManifestMIMEType:            manifestType,
                ImageListSelection:               imageListSelection,
                PreserveDigests:                  opts.PreserveDigests,
                //OciDecryptConfig:                 decConfig,
                //OciEncryptLayers:                 encLayers,
                //OciEncryptConfig:                 encConfig,
        }

        return retry.IfNecessary(ctx, func() error </span><span class="cov8" title="1">{
                //manifestBytes, err := copy.Image(ctx, policyContext, destRef, srcRef, &amp;copy.Options{
                manifestBytes, err := o.mc.CopyImage(ctx, policyContext, destRef, srcRef, co)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">out.Flush()
                if opts.DigestFile != "" </span><span class="cov0" title="0">{
                        manifestDigest, err := manifest.Digest(manifestBytes)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err = os.WriteFile(opts.DigestFile, []byte(manifestDigest.String()), 0644); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("Failed to write digest to file %q: %w", opts.DigestFile, err)
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }, opts.RetryOpts)
}

// delete - delete images
func (o *Mirror) delete(ctx context.Context, image string, opts *CopyOptions) error <span class="cov0" title="0">{

        if err := ReexecIfNecessaryForImages([]string{image}...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">imageRef, err := alltransports.ParseImageName(image)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Invalid source name %s: %v", image, err)
        }</span>

        <span class="cov0" title="0">sysCtx, err := opts.DestImage.NewSystemContext()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">ctx, cancel := opts.Global.CommandTimeoutContext()
        defer cancel()

        return retry.IfNecessary(ctx, func() error </span><span class="cov0" title="0">{
                err := imageRef.DeleteImage(ctx, sysCtx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }, opts.RetryOpts)
}

// parseMultiArch
func parseMultiArch(multiArch string) (copy.ImageListSelection, error) <span class="cov8" title="1">{
        switch multiArch </span>{
        case "system":<span class="cov0" title="0">
                return copy.CopySystemImage, nil</span>
        case "all":<span class="cov8" title="1">
                return copy.CopyAllImages, nil</span>
        // There is no CopyNoImages value in copy.ImageListSelection, but because we
        // don't provide an option to select a set of images to copy, we can use
        // CopySpecificImages.
        case "index-only":<span class="cov0" title="0">
                return copy.CopySpecificImages, nil</span>
        // We don't expose CopySpecificImages other than index-only above, because
        // we currently don't provide an option to choose the images to copy. That
        // could be added in the future.
        default:<span class="cov0" title="0">
                return copy.CopySystemImage, fmt.Errorf("unknown multi-arch option %q. Choose one of the supported options: 'system', 'all', or 'index-only'", multiArch)</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package mirror

import (
        "context"
        "errors"
        "fmt"
        "io"
        "os"
        "strings"
        "time"

        commonFlag "github.com/containers/common/pkg/flag"
        "github.com/containers/common/pkg/retry"
        "github.com/containers/image/v5/manifest"
        "github.com/containers/image/v5/signature"
        "github.com/containers/image/v5/types"
        "github.com/google/uuid"
        imgspecv1 "github.com/opencontainers/image-spec/specs-go/v1"
        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/pflag"
        "golang.org/x/term"
)

const defaultUserAgent string = "skopeo/v.19.5"

// errorShouldDisplayUsage is a subtype of error used by command handlers to indicate that cli.ShowSubcommandHelp should be called.
type ErrorShouldDisplayUsage struct {
        Error error
}

// noteCloseFailure returns (possibly-nil) err modified to account for (non-nil) closeErr.
// The error for closeErr is annotated with description (which is not a format string)
// Typical usage:
//
//        defer func() {
//                if err := something.Close(); err != nil {
//                        returnedErr = noteCloseFailure(returnedErr, "closing something", err)
//                }
//        }
func NoteCloseFailure(err error, description string, closeErr error) error <span class="cov0" title="0">{
        // We dont accept a Closer() and close it ourselves because signature.PolicyContext has .Destroy(), not .Close().
        // This also makes it harder for a caller to do
        //     defer noteCloseFailure(returnedErr, )
        // which doesnt use the right value of returnedErr, and doesnt update it.
        if err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("%s: %w", description, closeErr)
        }</span>
        // In this case we prioritize the primary error for use with %w; closeErr is usually less relevant, or might be a consequence of the primary erorr.
        <span class="cov0" title="0">return fmt.Errorf("%w (%s: %v)", err, description, closeErr)</span>
}

// commandAction intermediates between the RunE interface and the real handler,
// primarily to ensure that cobra.Command is not available to the handler, which in turn
// makes sure that the cmd.Flags() etc. flag access functions are not used,
// and everything is done using the *Options structures and the *Var() methods of cmd.Flag().
// handler may return errorShouldDisplayUsage to cause c.Help to be called.
func CommandAction(handler func(args []string, stdout io.Writer) error) func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        return func(c *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                err := handler(args, c.OutOrStdout())
                //var shouldDisplayUsage = &amp;ErrorShouldDisplayUsage{}
                //if errors.As(err, &amp;ErrorShouldDisplayUsage{}) {
                //        return c.Help()
                //}
                return err
        }</span>
}

// deprecatedTLSVerifyOption represents a deprecated --tls-verify option,
// which was accepted for all subcommands, for a time.
// Every user should call deprecatedTLSVerifyOption.warnIfUsed() as part of handling the CLI,
// whether or not the value actually ends up being used.
// DO NOT ADD ANY NEW USES OF THIS; just call dockerImageFlags with an appropriate, possibly empty, flagPrefix.
type DeprecatedTLSVerifyOption struct {
        tlsVerify commonFlag.OptionalBool // FIXME FIXME: Warn if this is used, or even if it is ignored.
}

// warnIfUsed warns if tlsVerify was set by the user, and suggests alternatives (which should
// start with "--").
// Every user should call this as part of handling the CLI, whether or not the value actually
// ends up being used.
func (opts *DeprecatedTLSVerifyOption) WarnIfUsed(alternatives []string) <span class="cov8" title="1">{
        if opts.tlsVerify.Present() </span><span class="cov0" title="0">{
                logrus.Warnf("'--tls-verify' is deprecated, instead use: %s", strings.Join(alternatives, ", "))
        }</span>
}

// deprecatedTLSVerifyFlags prepares the CLI flag writing into deprecatedTLSVerifyOption, and the managed deprecatedTLSVerifyOption structure.
// DO NOT ADD ANY NEW USES OF THIS; just call dockerImageFlags with an appropriate, possibly empty, flagPrefix.
func DeprecatedTLSVerifyFlags() (pflag.FlagSet, *DeprecatedTLSVerifyOption) <span class="cov8" title="1">{
        opts := DeprecatedTLSVerifyOption{}
        fs := pflag.FlagSet{}
        flag := commonFlag.OptionalBoolFlag(&amp;fs, &amp;opts.tlsVerify, "tls-verify", "require HTTPS and verify certificates when accessing the container registry")
        flag.Hidden = true
        return fs, &amp;opts
}</span>

// sharedImageOptions collects CLI flags which are image-related, but do not change across images.
// This really should be a part of globalOptions, but that would break existing users of (skopeo copy --authfile=).
type SharedImageOptions struct {
        authFilePath string // Path to a */containers/auth.json
}

// sharedImageFlags prepares a collection of CLI flags writing into sharedImageOptions, and the managed sharedImageOptions structure.
func SharedImageFlags() (pflag.FlagSet, *SharedImageOptions) <span class="cov8" title="1">{
        opts := SharedImageOptions{}
        fs := pflag.FlagSet{}
        fs.StringVar(&amp;opts.authFilePath, "authfile", os.Getenv("REGISTRY_AUTH_FILE"), "path of the authentication file. Default is ${XDG_RUNTIME_DIR}/containers/auth.json")
        return fs, &amp;opts
}</span>

// dockerImageOptions collects CLI flags specific to the "docker" transport, which are
// the same across subcommands, but may be different for each image
// (e.g. may differ between the source and destination of a copy)
type dockerImageOptions struct {
        global              *GlobalOptions             // May be shared across several imageOptions instances.
        shared              *SharedImageOptions        // May be shared across several imageOptions instances.
        deprecatedTLSVerify *DeprecatedTLSVerifyOption // May be shared across several imageOptions instances, or nil.
        authFilePath        commonFlag.OptionalString  // Path to a */containers/auth.json (prefixed version to override shared image option).
        credsOption         commonFlag.OptionalString  // username[:password] for accessing a registry
        userName            commonFlag.OptionalString  // username for accessing a registry
        password            commonFlag.OptionalString  // password for accessing a registry
        registryToken       commonFlag.OptionalString  // token to be used directly as a Bearer token when accessing the registry
        dockerCertPath      string                     // A directory using Docker-like *.{crt,cert,key} files for connecting to a registry or a daemon
        tlsVerify           commonFlag.OptionalBool    // Require HTTPS and verify certificates (for docker: and docker-daemon:)
        noCreds             bool                       // Access the registry anonymously
}

// imageOptions collects CLI flags which are the same across subcommands, but may be different for each image
// (e.g. may differ between the source and destination of a copy)
type imageOptions struct {
        dockerImageOptions
        sharedBlobDir    string // A directory to use for OCI blobs, shared across repositories
        dockerDaemonHost string // docker-daemon: host to connect to
}

// dockerImageFlags prepares a collection of docker-transport specific CLI flags
// writing into imageOptions, and the managed imageOptions structure.
func dockerImageFlags(global *GlobalOptions, shared *SharedImageOptions, deprecatedTLSVerify *DeprecatedTLSVerifyOption, flagPrefix, credsOptionAlias string) (pflag.FlagSet, *imageOptions) <span class="cov8" title="1">{
        flags := imageOptions{
                dockerImageOptions: dockerImageOptions{
                        global:              global,
                        shared:              shared,
                        deprecatedTLSVerify: deprecatedTLSVerify,
                },
        }

        fs := pflag.FlagSet{}
        if flagPrefix != "" </span><span class="cov8" title="1">{
                // the non-prefixed flag is handled by a shared flag.
                fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.authFilePath), flagPrefix+"authfile", "path of the authentication file. Default is ${XDG_RUNTIME_DIR}/containers/auth.json")
        }</span>
        <span class="cov8" title="1">fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.credsOption), flagPrefix+"creds", "Use `USERNAME[:PASSWORD]` for accessing the registry")
        fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.userName), flagPrefix+"username", "Username for accessing the registry")
        fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.password), flagPrefix+"password", "Password for accessing the registry")
        if credsOptionAlias != "" </span><span class="cov8" title="1">{
                // This is horribly ugly, but we need to support the old option forms of (skopeo copy) for compatibility.
                // Don't add any more cases like this.
                f := fs.VarPF(commonFlag.NewOptionalStringValue(&amp;flags.credsOption), credsOptionAlias, "", "Use `USERNAME[:PASSWORD]` for accessing the registry")
                f.Hidden = true
        }</span>
        <span class="cov8" title="1">fs.Var(commonFlag.NewOptionalStringValue(&amp;flags.registryToken), flagPrefix+"registry-token", "Provide a Bearer token for accessing the registry")
        fs.StringVar(&amp;flags.dockerCertPath, flagPrefix+"cert-dir", "", "use certificates at `PATH` (*.crt, *.cert, *.key) to connect to the registry or daemon")
        commonFlag.OptionalBoolFlag(&amp;fs, &amp;flags.tlsVerify, flagPrefix+"tls-verify", "require HTTPS and verify certificates when talking to the container registry or daemon")
        fs.BoolVar(&amp;flags.noCreds, flagPrefix+"no-creds", false, "Access the registry anonymously")
        return fs, &amp;flags</span>
}

// imageFlags prepares a collection of CLI flags writing into imageOptions, and the managed imageOptions structure.
func ImageFlags(global *GlobalOptions, shared *SharedImageOptions, deprecatedTLSVerify *DeprecatedTLSVerifyOption, flagPrefix, credsOptionAlias string) (pflag.FlagSet, *imageOptions) <span class="cov8" title="1">{
        dockerFlags, opts := dockerImageFlags(global, shared, deprecatedTLSVerify, flagPrefix, credsOptionAlias)

        fs := pflag.FlagSet{}
        fs.StringVar(&amp;opts.sharedBlobDir, flagPrefix+"shared-blob-dir", "", "`DIRECTORY` to use to share blobs across OCI repositories")
        fs.StringVar(&amp;opts.dockerDaemonHost, flagPrefix+"daemon-host", "", "use docker daemon host at `HOST` (docker-daemon: only)")
        fs.AddFlagSet(&amp;dockerFlags)
        return fs, opts
}</span>

func RetryFlags() (pflag.FlagSet, *retry.Options) <span class="cov8" title="1">{
        opts := retry.Options{}
        fs := pflag.FlagSet{}
        fs.IntVar(&amp;opts.MaxRetry, "retry-times", 0, "the number of times to possibly retry")
        return fs, &amp;opts
}</span>

// getPolicyContext returns a *signature.PolicyContext based on opts.
func (opts *GlobalOptions) GetPolicyContext() (*signature.PolicyContext, error) <span class="cov8" title="1">{
        var policy *signature.Policy // This could be cached across calls in opts.
        var err error
        if opts.InsecurePolicy </span><span class="cov8" title="1">{
                policy = &amp;signature.Policy{Default: []signature.PolicyRequirement{signature.NewPRInsecureAcceptAnything()}}
        }</span> else<span class="cov0" title="0"> if opts.PolicyPath == "" </span><span class="cov0" title="0">{
                policy, err = signature.DefaultPolicy(nil)
        }</span> else<span class="cov0" title="0"> {
                policy, err = signature.NewPolicyFromFile(opts.PolicyPath)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return signature.NewPolicyContext(policy)</span>
}

// commandTimeoutContext returns a context.Context and a cancellation callback based on opts.
// The caller should usually "defer cancel()" immediately after calling this.
func (opts *GlobalOptions) CommandTimeoutContext() (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        ctx := context.Background()
        var cancel context.CancelFunc = func() </span>{<span class="cov8" title="1">
                // empty function - its ok for now
        }</span>
        <span class="cov8" title="1">if opts.CommandTimeout &gt; 0 </span><span class="cov0" title="0">{
                ctx, cancel = context.WithTimeout(ctx, opts.CommandTimeout)
        }</span>
        <span class="cov8" title="1">return ctx, cancel</span>
}

// newSystemContext returns a *types.SystemContext corresponding to opts.
// It is guaranteed to return a fresh instance, so it is safe to make additional updates to it.
func (opts *GlobalOptions) NewSystemContext() *types.SystemContext <span class="cov8" title="1">{
        ctx := &amp;types.SystemContext{
                RegistriesDirPath:        opts.RegistriesDirPath,
                ArchitectureChoice:       opts.OverrideArch,
                OSChoice:                 opts.OverrideOS,
                VariantChoice:            opts.OverrideVariant,
                SystemRegistriesConfPath: opts.RegistriesConfPath,
                BigFilesTemporaryDir:     opts.TmpDir,
                DockerRegistryUserAgent:  defaultUserAgent,
        }
        // DEPRECATED: We support this for backward compatibility, but override it if a per-image flag is provided.
        if !opts.TlsVerify </span><span class="cov8" title="1">{
                ctx.DockerInsecureSkipTLSVerify = types.NewOptionalBool(true)
        }</span>
        <span class="cov8" title="1">return ctx</span>
}

// newSystemContext returns a *types.SystemContext corresponding to opts.
// It is guaranteed to return a fresh instance, so it is safe to make additional updates to it.
func (opts *imageOptions) NewSystemContext() (*types.SystemContext, error) <span class="cov8" title="1">{
        // *types.SystemContext instance from globalOptions
        //  imageOptions option overrides the instance if both are present.
        ctx := opts.global.NewSystemContext()
        ctx.DockerCertPath = opts.dockerCertPath
        ctx.OCISharedBlobDirPath = opts.sharedBlobDir
        ctx.AuthFilePath = opts.shared.authFilePath
        ctx.DockerDaemonHost = opts.dockerDaemonHost
        ctx.DockerDaemonCertPath = opts.dockerCertPath
        if opts.dockerImageOptions.authFilePath.Present() </span><span class="cov0" title="0">{
                ctx.AuthFilePath = opts.dockerImageOptions.authFilePath.Value()
        }</span>
        <span class="cov8" title="1">if opts.deprecatedTLSVerify != nil &amp;&amp; opts.deprecatedTLSVerify.tlsVerify.Present() </span><span class="cov0" title="0">{
                // If both this deprecated option and a non-deprecated option is present, we use the latter value.
                ctx.DockerInsecureSkipTLSVerify = types.NewOptionalBool(!opts.deprecatedTLSVerify.tlsVerify.Value())
        }</span>
        <span class="cov8" title="1">if opts.tlsVerify.Present() </span><span class="cov0" title="0">{
                ctx.DockerDaemonInsecureSkipTLSVerify = !opts.tlsVerify.Value()
        }</span>
        <span class="cov8" title="1">if opts.tlsVerify.Present() </span><span class="cov0" title="0">{
                ctx.DockerInsecureSkipTLSVerify = types.NewOptionalBool(!opts.tlsVerify.Value())
        }</span>
        <span class="cov8" title="1">if opts.credsOption.Present() &amp;&amp; opts.noCreds </span><span class="cov0" title="0">{
                return nil, errors.New("creds and no-creds cannot be specified at the same time")
        }</span>
        <span class="cov8" title="1">if opts.userName.Present() &amp;&amp; opts.noCreds </span><span class="cov0" title="0">{
                return nil, errors.New("username and no-creds cannot be specified at the same time")
        }</span>
        <span class="cov8" title="1">if opts.credsOption.Present() &amp;&amp; opts.userName.Present() </span><span class="cov0" title="0">{
                return nil, errors.New("creds and username cannot be specified at the same time")
        }</span>
        // if any of username or password is present, then both are expected to be present
        <span class="cov8" title="1">if opts.userName.Present() != opts.password.Present() </span><span class="cov0" title="0">{
                if opts.userName.Present() </span><span class="cov0" title="0">{
                        return nil, errors.New("password must be specified when username is specified")
                }</span>
                <span class="cov0" title="0">return nil, errors.New("username must be specified when password is specified")</span>
        }
        <span class="cov8" title="1">if opts.credsOption.Present() </span><span class="cov0" title="0">{
                var err error
                ctx.DockerAuthConfig, err = getDockerAuth(opts.credsOption.Value())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> if opts.userName.Present() </span><span class="cov0" title="0">{
                ctx.DockerAuthConfig = &amp;types.DockerAuthConfig{
                        Username: opts.userName.Value(),
                        Password: opts.password.Value(),
                }
        }</span>
        <span class="cov8" title="1">if opts.registryToken.Present() </span><span class="cov0" title="0">{
                ctx.DockerBearerRegistryToken = opts.registryToken.Value()
        }</span>
        <span class="cov8" title="1">if opts.noCreds </span><span class="cov0" title="0">{
                ctx.DockerAuthConfig = &amp;types.DockerAuthConfig{}
        }</span>

        <span class="cov8" title="1">return ctx, nil</span>
}

// imageDestOptions is a superset of imageOptions specialized for image destinations.
type imageDestOptions struct {
        *imageOptions
        dirForceCompression         bool                   // Compress layers when saving to the dir: transport
        dirForceDecompression       bool                   // Decompress layers when saving to the dir: transport
        ociAcceptUncompressedLayers bool                   // Whether to accept uncompressed layers in the oci: transport
        compressionFormat           string                 // Format to use for the compression
        compressionLevel            commonFlag.OptionalInt // Level to use for the compression
        precomputeDigests           bool                   // Precompute digests to dedup layers when saving to the docker: transport
}

// imageDestFlags prepares a collection of CLI flags writing into imageDestOptions, and the managed imageDestOptions structure.
func ImageDestFlags(global *GlobalOptions, shared *SharedImageOptions, deprecatedTLSVerify *DeprecatedTLSVerifyOption, flagPrefix, credsOptionAlias string) (pflag.FlagSet, *imageDestOptions) <span class="cov8" title="1">{
        genericFlags, genericOptions := ImageFlags(global, shared, deprecatedTLSVerify, flagPrefix, credsOptionAlias)
        opts := imageDestOptions{imageOptions: genericOptions}
        fs := pflag.FlagSet{}
        fs.AddFlagSet(&amp;genericFlags)
        fs.BoolVar(&amp;opts.dirForceCompression, flagPrefix+"compress", false, "Compress tarball image layers when saving to directory using the 'dir' transport. (default is same compression type as source)")
        fs.BoolVar(&amp;opts.dirForceDecompression, flagPrefix+"decompress", false, "Decompress tarball image layers when saving to directory using the 'dir' transport. (default is same compression type as source)")
        fs.BoolVar(&amp;opts.ociAcceptUncompressedLayers, flagPrefix+"oci-accept-uncompressed-layers", false, "Allow uncompressed image layers when saving to an OCI image using the 'oci' transport. (default is to compress things that aren't compressed)")
        fs.StringVar(&amp;opts.compressionFormat, flagPrefix+"compress-format", "", "`FORMAT` to use for the compression")
        fs.Var(commonFlag.NewOptionalIntValue(&amp;opts.compressionLevel), flagPrefix+"compress-level", "`LEVEL` to use for the compression")
        fs.BoolVar(&amp;opts.precomputeDigests, flagPrefix+"precompute-digests", false, "Precompute digests to prevent uploading layers already on the registry using the 'docker' transport.")
        return fs, &amp;opts
}</span>

/*
// newSystemContext returns a *types.SystemContext corresponding to opts.
// It is guaranteed to return a fresh instance, so it is safe to make additional updates to it.
func (opts *imageDestOptions) newSystemContext() (*types.SystemContext, error) {
        ctx, err := opts.imageOptions.NewSystemContext()
        if err != nil {
                return nil, err
        }

        ctx.DirForceCompress = opts.dirForceCompression
        ctx.DirForceDecompress = opts.dirForceDecompression
        ctx.OCIAcceptUncompressedLayers = opts.ociAcceptUncompressedLayers
        if opts.compressionFormat != "" {
                cf, err := compression.AlgorithmByName(opts.compressionFormat)
                if err != nil {
                        return nil, err
                }
                ctx.CompressionFormat = &amp;cf
        }
        if opts.compressionLevel.Present() {
                value := opts.compressionLevel.Value()
                ctx.CompressionLevel = &amp;value
        }
        ctx.DockerRegistryPushPrecomputeDigests = opts.precomputeDigests
        return ctx, err
}
*/

func parseCreds(creds string) (string, string, error) <span class="cov0" title="0">{
        if creds == "" </span><span class="cov0" title="0">{
                return "", "", errors.New("credentials can't be empty")
        }</span>
        <span class="cov0" title="0">up := strings.SplitN(creds, ":", 2)
        if len(up) == 1 </span><span class="cov0" title="0">{
                return up[0], "", nil
        }</span>
        <span class="cov0" title="0">if up[0] == "" </span><span class="cov0" title="0">{
                return "", "", errors.New("username can't be empty")
        }</span>
        <span class="cov0" title="0">return up[0], up[1], nil</span>
}

func getDockerAuth(creds string) (*types.DockerAuthConfig, error) <span class="cov0" title="0">{
        username, password, err := parseCreds(creds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;types.DockerAuthConfig{
                Username: username,
                Password: password,
        }, nil</span>
}

/*
// parseImageSource converts image URL-like string to an ImageSource.
// The caller must call .Close() on the returned ImageSource.
func parseImageSource(ctx context.Context, opts *imageOptions, name string) (types.ImageSource, error) {
        ref, err := alltransports.ParseImageName(name)
        if err != nil {
                return nil, err
        }
        sys, err := opts.NewSystemContext()
        if err != nil {
                return nil, err
        }
        return ref.NewImageSource(ctx, sys)
}
*/

// parseManifestFormat parses format parameter for copy and sync command.
// It returns string value to use as manifest MIME type
func ParseManifestFormat(manifestFormat string) (string, error) <span class="cov8" title="1">{
        switch manifestFormat </span>{
        case "oci":<span class="cov8" title="1">
                return imgspecv1.MediaTypeImageManifest, nil</span>
        case "v2s1":<span class="cov0" title="0">
                return manifest.DockerV2Schema1SignedMediaType, nil</span>
        case "v2s2":<span class="cov0" title="0">
                return manifest.DockerV2Schema2MediaType, nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unknown format %q. Choose one of the supported formats: 'oci', 'v2s1', or 'v2s2'", manifestFormat)</span>
        }
}

/*
// usageTemplate returns the usage template for skopeo commands
// This blocks the displaying of the global options. The main skopeo
// command should not use this.
const usageTemplate = `Usage:{{if .Runnable}}
{{.UseLine}}{{end}}{{if .HasAvailableSubCommands}}
{{.CommandPath}} [command]{{end}}{{if gt (len .Aliases) 0}}
Aliases:
{{.NameAndAliases}}{{end}}{{if .HasExample}}
Examples:
{{.Example}}{{end}}{{if .HasAvailableSubCommands}}
Available Commands:{{range .Commands}}{{if (or .IsAvailableCommand (eq .Name "help"))}}
{{rpad .Name .NamePadding }} {{.Short}}{{end}}{{end}}{{end}}{{if .HasAvailableLocalFlags}}
Flags:
{{.LocalFlags.FlagUsages | trimTrailingWhitespaces}}{{end}}{{if .HasAvailableInheritedFlags}}
{{end}}
`
*/

/*
// adjustUsage uses usageTemplate template to get rid the GlobalOption from usage
// and disable [flag] at the end of command usage
func adjustUsage(c *cobra.Command) {
        c.SetUsageTemplate(usageTemplate)
        c.DisableFlagsInUseLine = true
}
*/

// promptForPassphrase interactively prompts for a passphrase related to privateKeyFile
func PromptForPassphrase(privateKeyFile string, stdin, stdout *os.File) (string, error) <span class="cov0" title="0">{
        stdinFd := int(stdin.Fd())
        if !term.IsTerminal(stdinFd) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Cannot prompt for a passphrase for key %s, standard input is not a TTY", privateKeyFile)
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(stdout, "Passphrase for key %s: ", privateKeyFile)
        passphrase, err := term.ReadPassword(stdinFd)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("Error reading password: %w", err)
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(stdout, "\n")
        return string(passphrase), nil</span>
}

type GlobalOptions struct {
        LogLevel           string        // one of info, debug, trace
        TlsVerify          bool          // Require HTTPS and verify certificates (for docker: and docker-daemon:)
        PolicyPath         string        // Path to a signature verification policy file
        InsecurePolicy     bool          // Use an "allow everything" signature verification policy
        RegistriesDirPath  string        // Path to a "registries.d" registry configuration directory
        OverrideArch       string        // Architecture to use for choosing images, instead of the runtime one
        OverrideOS         string        // OS to use for choosing images, instead of the runtime one
        OverrideVariant    string        // Architecture variant to use for choosing images, instead of the runtime one
        CommandTimeout     time.Duration // Timeout for the command execution
        RegistriesConfPath string        // Path to the "registries.conf" file
        TmpDir             string        // Path to use for big temporary files
        Dir                string        // working directory
        ConfigPath         string        // Path to use for imagesetconfig
        From               string        // Used for mirroring (diskToMirror)
        Quiet              bool          // Suppress output information when copying images
        Force              bool          // Force the copy/mirror even if there is nothing to update
}

type CopyOptions struct {
        Global                   *GlobalOptions
        DeprecatedTLSVerify      *DeprecatedTLSVerifyOption
        SrcImage                 *imageOptions
        DestImage                *imageDestOptions
        RetryOpts                *retry.Options
        AdditionalTags           []string  // For docker-archive: destinations, in addition to the name:tag specified as destination, also add these
        RemoveSignatures         bool      // Do not copy signatures from the source image
        SignByFingerprint        string    // Sign the image using a GPG key with the specified fingerprint
        SignBySigstorePrivateKey string    // Sign the image using a sigstore private key
        SignPassphraseFile       string    // Path pointing to a passphrase file when signing (for either signature format, but only one of them)
        SignIdentity             string    // Identity of the signed image, must be a fully specified docker reference
        DigestFile               string    // Write digest to this file
        Format                   string    // Force conversion of the image to a specified format
        All                      bool      // Copy all of the images if the source is a list
        MultiArch                string    // How to handle multi architecture images
        PreserveDigests          bool      // Preserve digests during copy
        EncryptLayer             []int     // The list of layers to encrypt
        EncryptionKeys           []string  // Keys needed to encrypt the image
        DecryptionKeys           []string  // Keys needed to decrypt the image
        Mode                     string    // 2 options disktoMirror or mirrorToDisk (for now)
        Dev                      bool      // developer mode - will be removed when completed
        Destination              string    // what to target to
        UUID                     uuid.UUID // set uuid
        ImageType                string    // release, catalog-operator, additionalImage
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mirror

import (
        "fmt"

        "github.com/containers/image/v5/transports/alltransports"
        "github.com/containers/storage/pkg/unshare"
        "github.com/syndtr/gocapability/capability"
)

var neededCapabilities = []capability.Cap{
        capability.CAP_CHOWN,
        capability.CAP_DAC_OVERRIDE,
        capability.CAP_FOWNER,
        capability.CAP_FSETID,
        capability.CAP_MKNOD,
        capability.CAP_SETFCAP,
}

func maybeReexec() error <span class="cov0" title="0">{
        // With Skopeo we need only the subset of the root capabilities necessary
        // for pulling an image to the storage.  Do not attempt to create a namespace
        // if we already have the capabilities we need.
        capabilities, err := capability.NewPid2(0)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading the current capabilities sets: %w", err)
        }</span>
        <span class="cov0" title="0">for _, cap := range neededCapabilities </span><span class="cov0" title="0">{
                if !capabilities.Get(capability.EFFECTIVE, cap) </span><span class="cov0" title="0">{
                        // We miss a capability we need, create a user namespaces
                        unshare.MaybeReexecUsingUserNamespace(true)
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func ReexecIfNecessaryForImages(imageNames ...string) error <span class="cov8" title="1">{
        // Check if container-storage is used before doing unshare
        for _, imageName := range imageNames </span><span class="cov8" title="1">{
                transport := alltransports.TransportFromImageName(imageName)
                // Hard-code the storage name to avoid a reference on c/image/storage.
                // See https://github.com/containers/skopeo/issues/771#issuecomment-563125006.
                if transport != nil &amp;&amp; transport.Name() == "containers-storage" </span><span class="cov0" title="0">{
                        return maybeReexec()
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package operator

import (
        "bufio"
        "context"
        "crypto/sha256"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha3"
        clog "github.com/lmzuccarelli/golang-oci-mirror/pkg/log"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/manifest"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror"
)

const (
        indexJson                   string = "index.json"
        operatorImageExtractDir     string = "hold-operator"
        workingDir                  string = "working-dir/"
        dockerProtocol              string = "docker://"
        ociProtocol                 string = "oci://"
        ociProtocolTrimmed          string = "oci:"
        releaseImageDir             string = "release-images"
        operatorImageDir            string = "operator-images"
        releaseImageExtractDir      string = "hold-release"
        releaseManifests            string = "release-manifests"
        imageReferences             string = "image-references"
        releaseImageExtractFullPath string = releaseImageExtractDir + "/" + releaseManifests + "/" + imageReferences
        blobsDir                    string = "/blobs/sha256/"
        diskToMirror                string = "diskToMirror"
        mirrorToDisk                string = "mirrorToDisk"
        errMsg                      string = "[OperatorImageCollector] %v "
        logsFile                    string = "logs/operator.log"
)

type CollectorInterface interface {
        OperatorImageCollector(ctx context.Context) ([]string, error)
}

func New(log clog.PluggableLoggerInterface,
        config v1alpha2.ImageSetConfiguration,
        opts mirror.CopyOptions,
        mirror mirror.MirrorInterface,
        manifest manifest.ManifestInterface,
) CollectorInterface <span class="cov0" title="0">{
        return &amp;Collector{Log: log, Config: config, Opts: opts, Mirror: mirror, Manifest: manifest}
}</span>

type Collector struct {
        Log      clog.PluggableLoggerInterface
        Mirror   mirror.MirrorInterface
        Manifest manifest.ManifestInterface
        Config   v1alpha2.ImageSetConfiguration
        Opts     mirror.CopyOptions
}

// OperatorImageCollector - this looks into the operator index image
// taking into account the mode we are in (mirrorToDisk, diskToMirror)
// the image is downloaded (oci format) and the index.json is inspected
// once unmarshalled, the links to manifests are inspected
func (o *Collector) OperatorImageCollector(ctx context.Context) ([]string, error) <span class="cov8" title="1">{

        var allImages []string
        compare := make(map[string]v1alpha3.ISCPackage)
        relatedImages := make(map[string][]v1alpha3.RelatedImage)
        label := "configs"
        if !strings.Contains(o.Opts.Destination, ociProtocol) &amp;&amp; !strings.Contains(o.Opts.Destination, dockerProtocol) </span><span class="cov0" title="0">{
                return []string{}, fmt.Errorf(errMsg, "destination must use oci:// or docker:// prefix")
        }</span>

        // compile a map to compare channels,min &amp; max versions
        <span class="cov8" title="1">for _, ops := range o.Config.Mirror.Operators </span><span class="cov8" title="1">{
                o.Log.Info("isc operators: %s\n", ops.Catalog)
                for _, pkg := range ops.Packages </span><span class="cov8" title="1">{
                        o.Log.Info("catalog packages: %s \n", pkg.Name)
                        for _, channel := range pkg.Channels </span><span class="cov8" title="1">{
                                compare[pkg.Name] = v1alpha3.ISCPackage{Channel: channel.Name, MinVersion: channel.MinVersion, MaxVersion: channel.MaxVersion}
                                o.Log.Info("channels: %v \n", compare)
                        }</span>
                }
        }

        // check the mode
        <span class="cov8" title="1">if o.Opts.Mode == mirrorToDisk </span><span class="cov8" title="1">{
                f, err := os.Create(logsFile)
                if err != nil </span><span class="cov8" title="1">{
                        o.Log.Error(errMsg, err)
                }</span>
                <span class="cov8" title="1">writer := bufio.NewWriter(f)
                defer f.Close()
                for _, op := range o.Config.Mirror.Operators </span><span class="cov8" title="1">{

                        if !o.Opts.Dev </span><span class="cov8" title="1">{
                                // download the operator index image
                                o.Log.Info("copying operator image %v", op.Catalog)
                                src := dockerProtocol + op.Catalog
                                dest := ociProtocolTrimmed + o.Opts.Global.Dir + "/" + operatorImageDir
                                err := o.Mirror.Run(ctx, src, dest, "copy", &amp;o.Opts, *writer)
                                writer.Flush()
                                if err != nil </span><span class="cov0" title="0">{
                                        o.Log.Error(errMsg, err)
                                }</span>
                                // read the logs
                                <span class="cov8" title="1">f, _ := os.ReadFile(logsFile)
                                lines := strings.Split(string(f), "\n")
                                for _, s := range lines </span><span class="cov8" title="1">{
                                        if len(s) &gt; 0 </span><span class="cov0" title="0">{
                                                o.Log.Debug("%s ", strings.ToLower(s))
                                        }</span>
                                }

                                // it's in oci format so we can go directly to the index.json file
                                <span class="cov8" title="1">oci, err := o.Manifest.GetImageIndex(o.Opts.Global.Dir + "/" + operatorImageDir)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []string{}, err
                                }</span>

                                //read the link to the manifest
                                <span class="cov8" title="1">if len(oci.Manifests) == 0 </span><span class="cov0" title="0">{
                                        return []string{}, fmt.Errorf("[OperatorImageCollector] no manifests found for %s ", op.Catalog)
                                }</span> else<span class="cov8" title="1"> {
                                        if !strings.Contains(oci.Manifests[0].Digest, "sha256") </span><span class="cov0" title="0">{
                                                return []string{}, fmt.Errorf("[OperatorImageCollector] the disgets seems to incorrect for %s ", op.Catalog)
                                        }</span>
                                }
                                <span class="cov8" title="1">manifest := strings.Split(oci.Manifests[0].Digest, ":")[1]
                                o.Log.Info("manifest %v", manifest)

                                // read the operator image manifest
                                oci, err = o.Manifest.GetImageManifest(o.Opts.Global.Dir + "/" + operatorImageDir + blobsDir + manifest)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []string{}, err
                                }</span>

                                // read the config digest to get the detailed manifest
                                // looking for the lable to search for a specific folder
                                <span class="cov8" title="1">ocs, err := o.Manifest.GetOperatorConfig(o.Opts.Global.Dir + "/" + operatorImageDir + blobsDir + strings.Split(oci.Config.Digest, ":")[1])
                                if err != nil </span><span class="cov0" title="0">{
                                        return []string{}, err
                                }</span>

                                <span class="cov8" title="1">label = ocs.Config.Labels.OperatorsOperatorframeworkIoIndexConfigsV1
                                o.Log.Info("label %s", label)

                                // untar all the blobs for the operator
                                // if the layer with "label (from previous step) is found to a specific folder"
                                err = o.Manifest.ExtractLayersOCI(o.Opts.Global.Dir+"/"+operatorImageDir+blobsDir, o.Opts.Global.Dir+"/"+operatorImageExtractDir, label, oci)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []string{}, err
                                }</span>
                        }

                        // select all packages
                        // this is the equivalent of the headOnly mode
                        // only the latest version of each operator will be selected
                        <span class="cov8" title="1">if len(op.Packages) == 0 </span><span class="cov8" title="1">{
                                relatedImages, err = o.Manifest.GetRelatedImagesFromCatalog(o.Opts.Global.Dir+"/"+operatorImageExtractDir, label)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []string{}, err
                                }</span>
                        } else<span class="cov8" title="1"> {
                                // iterate through each package
                                relatedImages, err = o.Manifest.GetRelatedImagesFromCatalogByFilter(o.Opts.Global.Dir+"/"+operatorImageExtractDir, label, op, compare)
                                if err != nil </span><span class="cov0" title="0">{
                                        return []string{}, err
                                }</span>
                        }
                }
                <span class="cov8" title="1">o.Log.Info("related images length %d ", len(relatedImages))
                var count = 0
                for _, v := range relatedImages </span><span class="cov8" title="1">{
                        count = count + len(v)
                }</span>
                <span class="cov8" title="1">o.Log.Info("images to copy (before duplicates) %d ", count)

                // remove all duplicates
                var cleanedImages []v1alpha3.RelatedImage
                imgs := cleanDuplicates(relatedImages)
                o.Log.Trace("flatenned %v ", imgs)
                o.Log.Debug("images to copy")
                for k, v := range imgs </span><span class="cov8" title="1">{
                        o.Log.Debug("  name %s", v)
                        o.Log.Debug("  image %s", k)
                        cleanedImages = append(cleanedImages, v1alpha3.RelatedImage{Name: v, Image: k})
                }</span>
                <span class="cov8" title="1">allImages, err = batchWorkerConverter(o.Log, o.Opts.Global.Dir, cleanedImages)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, err
                }</span>
        }

        <span class="cov8" title="1">if o.Opts.Mode == diskToMirror </span><span class="cov0" title="0">{
                if len(o.Opts.Global.From) == 0 </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf(errMsg, "in diskToMirror mode please use the --from flag")
                }</span>
                // check the directory to copy
                <span class="cov0" title="0">regex, e := regexp.Compile(indexJson)
                if e != nil </span><span class="cov0" title="0">{
                        o.Log.Error("%v", e)
                }</span>
                <span class="cov0" title="0">e = filepath.Walk(workingDir+"/"+o.Opts.Global.From+"/"+operatorImageDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err == nil &amp;&amp; regex.MatchString(info.Name()) </span><span class="cov0" title="0">{
                                ns := strings.Split(filepath.Dir(path), operatorImageDir)
                                if len(ns) == 0 </span><span class="cov0" title="0">{
                                        return fmt.Errorf(errMsg+"%s", "no directory found for operator-images ", path)
                                }</span> else<span class="cov0" title="0"> {
                                        name := strings.Split(ns[1], "/")
                                        if len(name) != 3 </span><span class="cov0" title="0">{
                                                return fmt.Errorf(errMsg+"%s", "operator name and related compents are incorrect", name)
                                        }</span>
                                        <span class="cov0" title="0">src := ociProtocolTrimmed + ns[0] + operatorImageDir + "/" + name[1] + "/" + name[2]
                                        dest := o.Opts.Destination + "/" + name[1]
                                        allImages = append(allImages, src+"*"+dest)</span>
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if e != nil </span><span class="cov0" title="0">{
                        return []string{}, e
                }</span>
        }
        <span class="cov8" title="1">return allImages, nil</span>
}

// cleanDuplicates - simple utility to remove duplicates
func cleanDuplicates(m map[string][]v1alpha3.RelatedImage) map[string]string <span class="cov8" title="1">{
        x := make(map[string]string)
        for _, v := range m </span><span class="cov8" title="1">{
                for _, ri := range v </span><span class="cov8" title="1">{
                        x[ri.Image] = ri.Name
                }</span>
        }
        <span class="cov8" title="1">return x</span>
}

// customImageParser - simple image string parser
func customImageParser(image string) (*v1alpha3.ImageRefSchema, error) <span class="cov8" title="1">{
        var irs *v1alpha3.ImageRefSchema
        var component string
        parts := strings.Split(image, "/")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return irs, fmt.Errorf("[customImageParser] image url seems to be wrong %s ", image)
        }</span>
        <span class="cov8" title="1">if strings.Contains(parts[2], "@") </span><span class="cov8" title="1">{
                component = strings.Split(parts[2], "@")[0]
        }</span> else<span class="cov0" title="0"> {
                component = parts[2]
        }</span>
        <span class="cov8" title="1">irs = &amp;v1alpha3.ImageRefSchema{Repository: parts[0], Namespace: parts[1], Component: component}
        return irs, nil</span>
}

// batchWorkerConverter convert RelatedImages to strings for batch worker
func batchWorkerConverter(log clog.PluggableLoggerInterface, dir string, images []v1alpha3.RelatedImage) ([]string, error) <span class="cov8" title="1">{
        var result []string
        for _, img := range images </span><span class="cov8" title="1">{
                irs, err := customImageParser(img.Image)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("[batchWorkerConverter] %v", err)
                        return result, err
                }</span>
                <span class="cov8" title="1">err = os.MkdirAll(dir+"/"+operatorImageDir+"/"+irs.Namespace, 0750)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("[batchWorkerConverter] %v", err)
                        return result, err
                }</span>
                <span class="cov8" title="1">src := dockerProtocol + img.Image
                if len(img.Name) == 0 </span><span class="cov0" title="0">{
                        timestamp := time.Now().Unix()
                        s := fmt.Sprintf("%d", timestamp)
                        img.Name = fmt.Sprintf("%x", sha256.Sum256([]byte(s)))[:6]
                }</span>
                <span class="cov8" title="1">dest := ociProtocolTrimmed + dir + "/" + operatorImageDir + "/" + irs.Namespace + "/" + img.Name
                log.Debug("source %s ", img.Image)
                log.Debug("destination %s ", dir+"/"+operatorImageDir+"/"+irs.Namespace+"/"+img.Name)
                result = append(result, src+"*"+dest)</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package release

import (
        "context"
        "fmt"

        "github.com/blang/semver/v4"
        "github.com/google/uuid"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
        clog "github.com/lmzuccarelli/golang-oci-mirror/pkg/log"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror"
)

type CincinnatiInterface interface {
        GetReleaseReferenceImages(ctx context.Context) map[string]struct{}
        NewOCPClient(uuid uuid.UUID) (Client, error)
        NewOKDClient(uuid uuid.UUID) (Client, error)
}

func NewCincinnati(log clog.PluggableLoggerInterface, config *v1alpha2.ImageSetConfiguration, opts *mirror.CopyOptions, c Client, b bool) CincinnatiInterface <span class="cov8" title="1">{
        return &amp;CincinnatiSchema{Log: log, Config: config, Opts: opts, Client: c, Fail: b}
}</span>

type CincinnatiSchema struct {
        Log    clog.PluggableLoggerInterface
        Config *v1alpha2.ImageSetConfiguration
        Opts   *mirror.CopyOptions
        Client Client
        Fail   bool
}

func (o *CincinnatiSchema) NewOCPClient(uuid uuid.UUID) (Client, error) <span class="cov8" title="1">{
        if o.Fail </span><span class="cov8" title="1">{
                return o.Client, fmt.Errorf("forced cincinnati error")
        }</span>
        <span class="cov8" title="1">return o.Client, nil</span>
}

func (o *CincinnatiSchema) NewOKDClient(uuid uuid.UUID) (Client, error) <span class="cov0" title="0">{
        return o.Client, nil
}</span>

func (o *CincinnatiSchema) GetReleaseReferenceImages(ctx context.Context) map[string]struct{} <span class="cov8" title="1">{

        var (
                releaseDownloads = downloads{}
                errs             = []error{}
        )

        for _, arch := range o.Config.Mirror.Platform.Architectures </span><span class="cov8" title="1">{

                versionsByChannel := make(map[string]v1alpha2.ReleaseChannel, len(o.Config.Mirror.Platform.Channels))

                for _, ch := range o.Config.Mirror.Platform.Channels </span><span class="cov8" title="1">{

                        var client Client //client := o.Client
                        var err error
                        switch ch.Type </span>{
                        case v1alpha2.TypeOCP:<span class="cov8" title="1">
                                client, err = o.NewOCPClient(o.Opts.UUID)
                                if err != nil </span><span class="cov8" title="1">{
                                        errs = append(errs, err)
                                }</span>
                        case v1alpha2.TypeOKD:<span class="cov0" title="0">
                                client, err = o.NewOKDClient(o.Opts.UUID)
                                if err != nil </span><span class="cov0" title="0">{
                                        errs = append(errs, err)
                                }</span>
                        default:<span class="cov0" title="0">
                                errs = append(errs, fmt.Errorf("invalid platform type %v", ch.Type))
                                continue</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, err)
                                continue</span>
                        }

                        <span class="cov8" title="1">if len(ch.MaxVersion) == 0 || len(ch.MinVersion) == 0 </span><span class="cov8" title="1">{

                                // Find channel maximum value and only set the minimum as well if heads-only is true
                                if len(ch.MaxVersion) == 0 </span><span class="cov8" title="1">{
                                        latest, err := GetChannelMinOrMax(ctx, client, arch, ch.Name, false)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errs = append(errs, err)
                                                continue</span>
                                        }

                                        // Update version to release channel
                                        <span class="cov8" title="1">ch.MaxVersion = latest.String()
                                        o.Log.Info("detected minimum version as %s", ch.MaxVersion)
                                        if len(ch.MinVersion) == 0 &amp;&amp; ch.IsHeadsOnly() </span><span class="cov8" title="1">{
                                                //min, found := prevChannels[ch.Name]
                                                //if !found {
                                                // Starting at a new headsOnly channels
                                                min := latest.String()
                                                //}
                                                ch.MinVersion = min
                                                o.Log.Info("detected minimum version as %s\n", ch.MinVersion)
                                        }</span>
                                }

                                // Find channel minimum if full is true or just the minimum is not set
                                // in the config
                                <span class="cov8" title="1">if len(ch.MinVersion) == 0 </span><span class="cov8" title="1">{
                                        first, err := GetChannelMinOrMax(ctx, client, arch, ch.Name, true)
                                        if err != nil </span><span class="cov0" title="0">{
                                                errs = append(errs, err)
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">ch.MinVersion = first.String()
                                        o.Log.Info("detected minimum version as %s\n", ch.MinVersion)</span>
                                }
                                <span class="cov8" title="1">versionsByChannel[ch.Name] = ch</span>
                        } else<span class="cov8" title="1"> {
                                // Range is set. Ensure full is true so this
                                // is skipped when processing release metadata.
                                o.Log.Info("processing minimum version %s and maximum version %s\n", ch.MinVersion, ch.MaxVersion)
                                ch.Full = true
                                versionsByChannel[ch.Name] = ch
                        }</span>

                        <span class="cov8" title="1">downloads, err := getChannelDownloads(ctx, o.Log, client, nil, ch, arch)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">releaseDownloads.Merge(downloads)</span>
                }

                // Update cfg release channels with maximum and minimum versions
                // if applicable
                <span class="cov8" title="1">for i, ch := range o.Config.Mirror.Platform.Channels </span><span class="cov8" title="1">{
                        ch, found := versionsByChannel[ch.Name]
                        if found </span><span class="cov8" title="1">{
                                o.Config.Mirror.Platform.Channels[i] = ch
                        }</span>
                }

                <span class="cov8" title="1">if len(o.Config.Mirror.Platform.Channels) &gt; 1 </span><span class="cov8" title="1">{
                        client, err := NewOCPClient(o.Opts.UUID)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">newDownloads, err := getCrossChannelDownloads(ctx, o.Log, client, arch, o.Config.Mirror.Platform.Channels)
                        if err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, fmt.Errorf("error calculating cross channel upgrades: %v", err))
                                continue</span>
                        }
                        <span class="cov0" title="0">releaseDownloads.Merge(newDownloads)</span>
                }
        }
        <span class="cov8" title="1">for _, e := range errs </span><span class="cov8" title="1">{
                o.Log.Error("error list %v ", e)
        }</span>
        <span class="cov8" title="1">return releaseDownloads</span>
}

type downloads map[string]struct{}

func (d downloads) Merge(in downloads) <span class="cov8" title="1">{
        for k, v := range in </span><span class="cov8" title="1">{
                _, ok := d[k]
                if ok </span><span class="cov0" title="0">{
                        //fmt.Printf("download %s exists", k)
                        continue</span>
                }
                <span class="cov8" title="1">d[k] = v</span>
        }
}

//var b []byte

// getDownloads will prepare the downloads map for mirroring
func getChannelDownloads(ctx context.Context, log clog.PluggableLoggerInterface, c Client, lastChannels []v1alpha2.ReleaseChannel, channel v1alpha2.ReleaseChannel, arch string) (downloads, error) <span class="cov8" title="1">{
        allDownloads := downloads{}

        var prevChannel v1alpha2.ReleaseChannel
        for _, ch := range lastChannels </span><span class="cov0" title="0">{
                if ch.Name == channel.Name </span><span class="cov0" title="0">{
                        prevChannel = ch
                }</span>
        }
        <span class="cov8" title="1">log.Trace("previous channel %v", prevChannel)
        // Plot between min and max of channel
        first, err := semver.Parse(channel.MinVersion)
        if err != nil </span><span class="cov0" title="0">{
                return allDownloads, err
        }</span>
        <span class="cov8" title="1">last, err := semver.Parse(channel.MaxVersion)
        if err != nil </span><span class="cov0" title="0">{
                return allDownloads, err
        }</span>

        <span class="cov8" title="1">var newDownloads downloads
        if channel.ShortestPath </span><span class="cov8" title="1">{
                current, newest, updates, err := CalculateUpgrades(ctx, c, arch, channel.Name, channel.Name, first, last)
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov8" title="1">newDownloads = gatherUpdates(log, current, newest, updates)</span>

        } else<span class="cov8" title="1"> {
                lowRange, err := semver.ParseRange(fmt.Sprintf("&gt;=%s", first))
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov8" title="1">highRange, err := semver.ParseRange(fmt.Sprintf("&lt;=%s", last))
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov8" title="1">versions, err := GetUpdatesInRange(ctx, c, channel.Name, arch, highRange.AND(lowRange))
                if err != nil </span><span class="cov0" title="0">{
                        return allDownloads, err
                }</span>
                <span class="cov8" title="1">newDownloads = gatherUpdates(log, Update{}, Update{}, versions)</span>
        }
        <span class="cov8" title="1">allDownloads.Merge(newDownloads)

        return allDownloads, nil</span>
}

// getCrossChannelDownloads will determine required downloads between channel versions (for OCP only)
func getCrossChannelDownloads(ctx context.Context, log clog.PluggableLoggerInterface, ocpClient Client, arch string, channels []v1alpha2.ReleaseChannel) (downloads, error) <span class="cov8" title="1">{
        // Strip any OKD channels from the list

        var ocpChannels []v1alpha2.ReleaseChannel
        for _, ch := range channels </span><span class="cov8" title="1">{
                if ch.Type == v1alpha2.TypeOCP </span><span class="cov8" title="1">{
                        ocpChannels = append(ocpChannels, ch)
                }</span>
        }
        // If no other channels exist, return no downloads
        <span class="cov8" title="1">if len(ocpChannels) == 0 </span><span class="cov0" title="0">{
                return downloads{}, nil
        }</span>

        <span class="cov8" title="1">firstCh, first, err := FindRelease(ocpChannels, true)
        if err != nil </span><span class="cov0" title="0">{
                return downloads{}, fmt.Errorf("failed to find minimum release version: %v", err)
        }</span>
        <span class="cov8" title="1">lastCh, last, err := FindRelease(ocpChannels, false)
        if err != nil </span><span class="cov0" title="0">{
                return downloads{}, fmt.Errorf("failed to find maximum release version: %v", err)
        }</span>
        <span class="cov8" title="1">current, newest, updates, err := CalculateUpgrades(ctx, ocpClient, arch, firstCh, lastCh, first, last)
        if err != nil </span><span class="cov8" title="1">{
                return downloads{}, fmt.Errorf("failed to get upgrade graph: %v", err)
        }</span>
        <span class="cov0" title="0">return gatherUpdates(log, current, newest, updates), nil</span>
}

// gatherUpdates
func gatherUpdates(log clog.PluggableLoggerInterface, current, newest Update, updates []Update) downloads <span class="cov8" title="1">{
        releaseDownloads := downloads{}
        for _, update := range updates </span><span class="cov8" title="1">{
                log.Info("Found update %s\n", update.Version)
                releaseDownloads[update.Image] = struct{}{}
        }</span>

        <span class="cov8" title="1">if current.Image != "" </span><span class="cov8" title="1">{
                releaseDownloads[current.Image] = struct{}{}
        }</span>

        <span class="cov8" title="1">if newest.Image != "" </span><span class="cov8" title="1">{
                releaseDownloads[newest.Image] = struct{}{}
        }</span>

        <span class="cov8" title="1">return releaseDownloads</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package release

import (
        "crypto/tls"
        "crypto/x509"
        "net/http"
        "net/url"
        "os"

        "github.com/google/uuid"
        "k8s.io/klog/v2"
)

// Client is a Cincinnati client which can be used to fetch update graphs from
// an upstream Cincinnati stack.
type Client interface {
        GetURL() *url.URL
        SetQueryParams(arch, channel, version string)
        GetID() uuid.UUID
        GetTransport() *http.Transport
}

var _ Client = &amp;ocpClient{}

type ocpClient struct {
        id        uuid.UUID
        transport *http.Transport
        url       url.URL
}

// NewOCPClient creates a new OCP Cincinnati client with the given client identifier.
func NewOCPClient(id uuid.UUID) (Client, error) <span class="cov8" title="1">{
        var updateGraphURL string
        if updateURLOverride := os.Getenv("UPDATE_URL_OVERRIDE"); len(updateURLOverride) != 0 </span><span class="cov8" title="1">{
                klog.Info("Usage of the UPDATE_URL_OVERRIDE environment variable is unsupported")
                updateGraphURL = updateURLOverride
        }</span> else<span class="cov8" title="1"> {
                updateGraphURL = UpdateURL
        }</span>
        <span class="cov8" title="1">upstream, err := url.Parse(updateGraphURL)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ocpClient{}, err
        }</span>

        <span class="cov8" title="1">tls, err := getTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;ocpClient{}, err
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: tls,
                Proxy:           http.ProxyFromEnvironment,
        }
        return &amp;ocpClient{id: id, transport: transport, url: *upstream}, nil</span>
}

func (c *ocpClient) GetURL() *url.URL <span class="cov8" title="1">{
        return &amp;c.url
}</span>

func (c *ocpClient) GetTransport() *http.Transport <span class="cov8" title="1">{
        return c.transport
}</span>

func (c *ocpClient) GetID() uuid.UUID <span class="cov8" title="1">{
        return c.id
}</span>

func (c *ocpClient) SetQueryParams(arch, channel, version string) <span class="cov8" title="1">{
        queryParams := c.url.Query()
        queryParams.Add("id", c.id.String())
        params := map[string]string{
                "arch":    arch,
                "channel": channel,
                "version": version,
        }
        for key, value := range params </span><span class="cov8" title="1">{
                if value != "" </span><span class="cov8" title="1">{
                        queryParams.Add(key, value)
                }</span>
        }
        <span class="cov8" title="1">c.url.RawQuery = queryParams.Encode()</span>
}

var _ Client = &amp;okdClient{}

type okdClient struct {
        id        uuid.UUID
        transport *http.Transport
        url       url.URL
}

// NewOKDClient creates a new OKD Cincinnati client with the given client identifier.
func NewOKDClient(id uuid.UUID) (Client, error) <span class="cov8" title="1">{
        upstream, err := url.Parse(OkdUpdateURL)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;okdClient{}, err
        }</span>

        <span class="cov8" title="1">tls, err := getTLSConfig()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;okdClient{}, err
        }</span>

        <span class="cov8" title="1">transport := &amp;http.Transport{
                TLSClientConfig: tls,
                Proxy:           http.ProxyFromEnvironment,
        }
        return &amp;okdClient{id: id, transport: transport, url: *upstream}, nil</span>
}

func (c *okdClient) GetURL() *url.URL <span class="cov8" title="1">{
        return &amp;c.url
}</span>

func (c *okdClient) GetID() uuid.UUID <span class="cov8" title="1">{
        return c.id
}</span>

func (c *okdClient) GetTransport() *http.Transport <span class="cov0" title="0">{
        return c.transport
}</span>

func (c *okdClient) SetQueryParams(_, _, _ string) {<span class="cov8" title="1">
        // Do nothing
}</span>

func getTLSConfig() (*tls.Config, error) <span class="cov8" title="1">{
        certPool, err := x509.SystemCertPool()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">config := &amp;tls.Config{
                RootCAs:    certPool,
                MinVersion: tls.VersionTLS12,
        }
        return config, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package release

import (
        "bufio"
        "context"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha3"
        clog "github.com/lmzuccarelli/golang-oci-mirror/pkg/log"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/manifest"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/mirror"
)

const (
        indexJson                   string = "index.json"
        operatorImageExtractDir     string = "hold-operator"
        workingDir                  string = "working-dir/"
        dockerProtocol              string = "docker://"
        ociProtocol                 string = "oci://"
        ociProtocolTrimmed          string = "oci:"
        releaseImageDir             string = "release-images"
        operatorImageDir            string = "operator-images"
        releaseImageExtractDir      string = "hold-release"
        releaseManifests            string = "release-manifests"
        imageReferences             string = "image-references"
        releaseImageExtractFullPath string = releaseImageExtractDir + "/" + releaseManifests + "/" + imageReferences
        blobsDir                    string = "/blobs/sha256/"
        errMsg                      string = "[ReleaseImageCollector] %v "
        diskToMirror                string = "diskToMirror"
        mirrorToDisk                string = "mirrorToDisk"
        logFile                     string = "logs/release.log"
)

type CollectorInterface interface {
        ReleaseImageCollector(ctx context.Context) ([]string, error)
}

func New(log clog.PluggableLoggerInterface,
        config v1alpha2.ImageSetConfiguration,
        opts mirror.CopyOptions,
        mirror mirror.MirrorInterface,
        manifest manifest.ManifestInterface,
        cincinnati CincinnatiInterface,
) CollectorInterface <span class="cov0" title="0">{
        return &amp;Collector{Log: log, Config: config, Opts: opts, Mirror: mirror, Manifest: manifest, Cincinnati: cincinnati}
}</span>

type Collector struct {
        Log        clog.PluggableLoggerInterface
        Mirror     mirror.MirrorInterface
        Manifest   manifest.ManifestInterface
        Config     v1alpha2.ImageSetConfiguration
        Opts       mirror.CopyOptions
        Cincinnati CincinnatiInterface
}

// ReleaseImageCollector - this looks into the operator index image
// taking into account the mode we are in (mirrorToDisk, diskToMirror)
// the image is downloaded (oci format) and the index.json is inspected
// once unmarshalled, the links to manifests are inspected
func (o *Collector) ReleaseImageCollector(ctx context.Context) ([]string, error) <span class="cov8" title="1">{

        var allImages []string

        if o.Opts.Mode == mirrorToDisk </span><span class="cov8" title="1">{
                releases := o.Cincinnati.GetReleaseReferenceImages(ctx)
                f, err := os.Create(logFile)
                if err != nil </span><span class="cov8" title="1">{
                        o.Log.Error("[ReleaseImageCollector] %v", err)
                }</span>
                <span class="cov8" title="1">if !strings.Contains(o.Opts.Destination, ociProtocol) </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf(" [ReleaseImageCollector] destination must use oci: or docker:// prefix")
                }</span>

                <span class="cov8" title="1">writer := bufio.NewWriter(f)
                defer f.Close()
                // dev mode debugging
                if !o.Opts.Dev </span><span class="cov8" title="1">{
                        for key := range releases </span><span class="cov8" title="1">{
                                o.Log.Info("copying image %s ", key)
                                src := dockerProtocol + key
                                dest := ociProtocolTrimmed + o.Opts.Global.Dir + "/" + releaseImageDir
                                err := o.Mirror.Run(ctx, src, dest, "copy", &amp;o.Opts, *writer)
                                if err != nil </span><span class="cov8" title="1">{
                                        return []string{}, fmt.Errorf(errMsg, err)
                                }</span>
                                <span class="cov8" title="1">o.Log.Debug("copied release index image %s ", key)

                                // TODO: create common function read the logs
                                f, _ := os.ReadFile(logFile)
                                lines := strings.Split(string(f), "\n")
                                for _, s := range lines </span><span class="cov8" title="1">{
                                        if len(s) &gt; 0 </span><span class="cov0" title="0">{
                                                o.Log.Debug(" %s ", strings.ToLower(s))
                                        }</span>
                                }
                        }
                }

                <span class="cov8" title="1">oci, err := o.Manifest.GetImageIndex(o.Opts.Global.Dir + "/" + releaseImageDir)
                if err != nil </span><span class="cov8" title="1">{
                        o.Log.Error("[ReleaseImageCollector] %v ", err)
                        return []string{}, fmt.Errorf(errMsg, err)
                }</span>

                //read the link to the manifest
                <span class="cov8" title="1">if len(oci.Manifests) == 0 </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf(errMsg, "image index not found ")
                }</span>
                <span class="cov8" title="1">manifest := strings.Split(oci.Manifests[0].Digest, ":")[1]
                o.Log.Debug("image index %v", manifest)

                oci, err = o.Manifest.GetImageManifest(o.Opts.Global.Dir + "/" + releaseImageDir + blobsDir + manifest)
                if err != nil </span><span class="cov8" title="1">{
                        return []string{}, fmt.Errorf(errMsg, err)
                }</span>
                <span class="cov8" title="1">o.Log.Debug("manifest %v ", oci.Config.Digest)

                err = o.Manifest.ExtractLayersOCI(o.Opts.Global.Dir+"/"+releaseImageDir+blobsDir, o.Opts.Global.Dir+"/"+releaseImageExtractDir, releaseManifests, oci)
                if err != nil </span><span class="cov8" title="1">{
                        return []string{}, fmt.Errorf(errMsg, err)
                }</span>
                <span class="cov8" title="1">o.Log.Debug("extracted oci layer %s ", workingDir+releaseImageExtractDir)

                allRelatedImages, err := o.Manifest.GetReleaseSchema(o.Opts.Global.Dir + "/" + releaseImageExtractFullPath)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf(errMsg, err)
                }</span>
                <span class="cov8" title="1">allImages, err = batcWorkerConverter(o.Log, o.Opts.Global.Dir, allRelatedImages)
                if err != nil </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf(errMsg, err)
                }</span>
        }
        <span class="cov8" title="1">if o.Opts.Mode == diskToMirror </span><span class="cov0" title="0">{
                if len(o.Opts.Global.From) == 0 </span><span class="cov0" title="0">{
                        return []string{}, fmt.Errorf(errMsg, "in diskToMirror mode please use the --from flag")
                }</span>
                // check the directory to copy
                <span class="cov0" title="0">regex, e := regexp.Compile(indexJson)
                if e != nil </span><span class="cov0" title="0">{
                        o.Log.Error(errMsg, e)
                }</span>
                <span class="cov0" title="0">e = filepath.Walk(workingDir+"/"+o.Opts.Global.From+"/"+releaseImageDir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if err == nil &amp;&amp; regex.MatchString(info.Name()) </span><span class="cov0" title="0">{
                                ns := strings.Split(filepath.Dir(path), releaseImageDir)
                                if len(ns) == 0 </span><span class="cov0" title="0">{
                                        return fmt.Errorf(errMsg, "no directory found for operator-images - please verify")
                                }</span> else<span class="cov0" title="0"> {
                                        name := strings.Split(ns[1], "/")
                                        if len(name) != 2 </span><span class="cov0" title="0">{
                                                return fmt.Errorf(errMsg+" %s ", "operator name and related compents are incorrect", name)
                                        }</span>
                                        <span class="cov0" title="0">src := ociProtocolTrimmed + ns[0] + releaseImageDir + "/" + name[1]
                                        dest := o.Opts.Destination + "/" + name[1]
                                        allImages = append(allImages, src+"*"+dest)</span>
                                }
                        }
                        <span class="cov0" title="0">return nil</span>
                })
                <span class="cov0" title="0">if e != nil </span><span class="cov0" title="0">{
                        return []string{}, e
                }</span>
        }

        <span class="cov8" title="1">return allImages, nil</span>

}

// batchWorkerConverter convert RelatedImages to strings for batch worker
func batcWorkerConverter(log clog.PluggableLoggerInterface, dir string, images []v1alpha3.RelatedImage) ([]string, error) <span class="cov8" title="1">{
        var result []string
        for _, img := range images </span><span class="cov8" title="1">{
                src := dockerProtocol + img.Image
                dest := ociProtocolTrimmed + dir + "/" + releaseImageDir + "/" + img.Name
                err := os.MkdirAll(dir+"/"+releaseImageDir+"/"+img.Name, 0750)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error("[batchWorkerConverter] %v", err)
                        return []string{}, err
                }</span>
                <span class="cov8" title="1">log.Debug("source %s ", src)
                log.Debug("destination %s ", dest)
                result = append(result, src+"*"+dest)</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package release

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/blang/semver/v4"
        "k8s.io/klog/v2"
)

const (
        // GraphMediaType is the media-type specified in the HTTP Accept header
        // of requests sent to the Cincinnati-v1 Graph API.
        GraphMediaType = "application/json"

        // Timeout when calling upstream Cincinnati stack.
        getUpdatesTimeout = time.Minute * 60
        // UpdateURL is the Cincinnati endpoint for the OpenShift platform.
        UpdateURL = "https://api.openshift.com/api/upgrades_info/v1/graph"
        // OkdUpdateURL is the Cincinnati endpoint for the OKD platform.
        OkdUpdateURL = "https://origin-release.ci.openshift.org/graph"

        ChannelInfo = "channel %q: %v"
)

// Error is returned when are unable to get updates.
type Error struct {
        // Reason is the reason suggested for the Cincinnati calculation error.
        Reason string

        // Message is the message suggested for Cincinnati calculation error..
        Message string

        // cause is the upstream error, if any, being wrapped by this error.
        cause error
}

// Error serializes the error as a string, to satisfy the error interface.
func (err *Error) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s: %s", err.Reason, err.Message)
}</span>

// Update is a single node from the update graph.
type Update node

// GetUpdates fetches the requested update payload from the specified
// upstream Cincinnati stack given the current version, architecture, and channel.
// The shortest path is calculated between the current and requested version from the graph edge
// data.
func GetUpdates(ctx context.Context, c Client, arch string, channel string, version semver.Version, reqVer semver.Version) (Update, Update, []Update, error) <span class="cov8" title="1">{
        var current Update
        var requested Update
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, version.String())

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf("version %s in channel %s: %v", version.String(), channel, err),
                        cause:   err,
                }
        }</span>

        // Find the current version within the graph.
        <span class="cov8" title="1">var currentIdx int
        found := false
        for i, node := range graph.Nodes </span><span class="cov8" title="1">{
                if version.EQ(node.Version) </span><span class="cov8" title="1">{
                        currentIdx = i
                        current = Update(graph.Nodes[i])
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return current, requested, nil, &amp;Error{
                        Reason:  "VersionNotFound",
                        Message: fmt.Sprintf("current version %s not found in the %q channel", version, channel),
                }
        }</span>

        <span class="cov8" title="1">var destinationIdx int
        found = false
        for i, node := range graph.Nodes </span><span class="cov8" title="1">{
                if reqVer.EQ(node.Version) </span><span class="cov8" title="1">{
                        destinationIdx = i
                        requested = Update(graph.Nodes[i])
                        found = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return current, requested, nil, &amp;Error{
                        Reason:  "VersionNotFound",
                        Message: fmt.Sprintf("requested version %s not found in the %q channel", reqVer, channel),
                }
        }</span>

        <span class="cov8" title="1">edgesByOrigin := make(map[int][]int, len(graph.Nodes))
        for _, edge := range graph.Edges </span><span class="cov8" title="1">{
                edgesByOrigin[edge.Origin] = append(edgesByOrigin[edge.Origin], edge.Destination)
        }</span>

        // Sort destination by semver to ensure deterministic result
        <span class="cov8" title="1">for origin, destinations := range edgesByOrigin </span><span class="cov8" title="1">{
                sort.Slice(destinations, func(i, j int) bool </span><span class="cov8" title="1">{
                        return graph.Nodes[destinations[i]].Version.GT(graph.Nodes[destinations[j]].Version)
                }</span>)
                <span class="cov8" title="1">edgesByOrigin[origin] = destinations</span>
        }

        <span class="cov8" title="1">shortestPath := func(g map[int][]int, start, end int) []int </span><span class="cov8" title="1">{
                prev := map[int]int{}
                visited := map[int]struct{}{}
                queue := []int{start}
                visited[start] = struct{}{}
                prev[start] = -1

                for len(queue) &gt; 0 </span><span class="cov8" title="1">{
                        node := queue[0]
                        queue = queue[1:]
                        if node == end </span><span class="cov8" title="1">{
                                break</span>
                        }

                        <span class="cov8" title="1">for _, neighbor := range g[node] </span><span class="cov8" title="1">{
                                if _, ok := visited[neighbor]; !ok </span><span class="cov8" title="1">{
                                        prev[neighbor] = node
                                        queue = append(queue, neighbor)
                                        visited[neighbor] = struct{}{}
                                }</span>
                        }
                }

                // No path to end
                <span class="cov8" title="1">if _, ok := visited[end]; !ok </span><span class="cov8" title="1">{
                        return []int{}
                }</span>

                <span class="cov8" title="1">path := []int{end}
                for next := prev[end]; next != -1; next = prev[next] </span><span class="cov8" title="1">{
                        path = append(path, next)
                }</span>

                // Reverse path.
                <span class="cov8" title="1">for i, j := 0, len(path)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                        path[i], path[j] = path[j], path[i]
                }</span>

                <span class="cov8" title="1">return path</span>
        }

        <span class="cov8" title="1">nextIdxs := shortestPath(edgesByOrigin, currentIdx, destinationIdx)

        var updates []Update
        for _, i := range nextIdxs </span><span class="cov8" title="1">{
                updates = append(updates, Update(graph.Nodes[i]))
        }</span>

        <span class="cov8" title="1">return current, requested, updates, nil</span>
}

// CalculateUpgrades fetches and calculates all the update payloads from the specified
// upstream Cincinnati stack given the current and target version and channel.
func CalculateUpgrades(ctx context.Context, c Client, arch, sourceChannel, targetChannel string, startVer, reqVer semver.Version) (Update, Update, []Update, error) <span class="cov8" title="1">{
        if sourceChannel == targetChannel </span><span class="cov8" title="1">{
                return GetUpdates(ctx, c, arch, targetChannel, startVer, reqVer)
        }</span>

        // Check the major and minor versions are the same with different
        // channel prefixes
        <span class="cov8" title="1">source, target, _, err := getSemverFromChannels(sourceChannel, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return Update{}, Update{}, nil, err
        }</span>
        <span class="cov8" title="1">if source.EQ(target) </span><span class="cov8" title="1">{
                isBlocked, err := handleBlockedEdges(ctx, c, arch, targetChannel, startVer)
                if err != nil </span><span class="cov0" title="0">{
                        return Update{}, Update{}, nil, err
                }</span>
                <span class="cov8" title="1">if isBlocked </span><span class="cov0" title="0">{
                        // If blocked path is found, just return the requested version and any accumulated
                        // upgrades to the caller
                        klog.Warningf("No upgrade path for %s in target channel %s", startVer.String(), targetChannel)
                        return GetUpdates(ctx, c, arch, targetChannel, reqVer, reqVer)
                }</span>
                <span class="cov8" title="1">return GetUpdates(ctx, c, arch, targetChannel, startVer, reqVer)</span>
        }

        // Perform initial calculation for the source channel and
        // recurse through the rest until the target or a blocked
        // edge is hit.
        <span class="cov8" title="1">latest, err := GetChannelMinOrMax(ctx, c, arch, sourceChannel, false)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, fmt.Errorf(ChannelInfo, sourceChannel, err)
        }</span>
        <span class="cov8" title="1">current, _, upgrades, err := GetUpdates(ctx, c, arch, sourceChannel, startVer, latest)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, fmt.Errorf(ChannelInfo, sourceChannel, err)
        }</span>

        <span class="cov8" title="1">requested, newUpgrades, err := calculate(ctx, c, arch, sourceChannel, targetChannel, latest, reqVer)
        if err != nil </span><span class="cov8" title="1">{
                return Update{}, Update{}, nil, err
        }</span>
        <span class="cov8" title="1">upgrades = append(upgrades, newUpgrades...)

        var finalUpgrades []Update
        seen := make(map[string]struct{}, len(upgrades))
        for _, upgrade := range upgrades </span><span class="cov8" title="1">{
                if _, ok := seen[upgrade.Image]; !ok </span><span class="cov8" title="1">{
                        finalUpgrades = append(finalUpgrades, upgrade)
                        seen[upgrade.Image] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">return current, requested, finalUpgrades, nil</span>
}

// calculate will calculate Cincinnati upgrades between channels by finding the latest versions in the source channels
// and incrementing the minor version until the target channel is reached.
func calculate(ctx context.Context, c Client, arch, sourceChannel, targetChannel string, startVer, reqVer semver.Version) (requested Update, upgrades []Update, err error) <span class="cov8" title="1">{
        source, target, prefix, err := getSemverFromChannels(sourceChannel, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        // We immediately bump the source channel since current source channel upgrades have
        // already been calculated
        <span class="cov8" title="1">source.Minor++
        currChannel := fmt.Sprintf("%s-%v.%v", prefix, source.Major, source.Minor)

        var targetVer semver.Version
        if source.EQ(target) </span><span class="cov8" title="1">{
                // If this is the target channel major.minor get
                // requested version, so we don't exceed the maximum version
                // Set the target channel to make sure we have the intended
                // channel prefix
                targetVer = reqVer
                currChannel = targetChannel
        }</span> else<span class="cov8" title="1"> {
                targetVer, err = GetChannelMinOrMax(ctx, c, arch, currChannel, false)
                if err != nil </span><span class="cov0" title="0">{
                        return requested, upgrades, err
                }</span>
        }

        <span class="cov8" title="1">isBlocked, err := handleBlockedEdges(ctx, c, arch, currChannel, startVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        <span class="cov8" title="1">if isBlocked </span><span class="cov8" title="1">{
                // If blocked path is found, just return the requested version and any accumulated
                // upgrades to the caller
                _, requested, _, err = GetUpdates(ctx, c, arch, targetChannel, targetVer, targetVer)
                //Warnf is 5?
                klog.Warningf("No upgrade path for %s in target channel %s", startVer.String(), targetChannel)
                return requested, upgrades, err
        }</span>

        <span class="cov8" title="1">klog.V(1).Infof("Getting updates for version %s in channel %s", startVer.String(), currChannel)
        _, requested, upgrades, err = GetUpdates(ctx, c, arch, currChannel, startVer, targetVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>

        <span class="cov8" title="1">if source.EQ(target) </span><span class="cov8" title="1">{
                return requested, upgrades, nil
        }</span>

        <span class="cov8" title="1">currRequested, currUpgrades, err := calculate(ctx, c, arch, currChannel, targetChannel, targetVer, reqVer)
        if err != nil </span><span class="cov0" title="0">{
                return requested, upgrades, err
        }</span>
        <span class="cov8" title="1">requested = currRequested
        upgrades = append(upgrades, currUpgrades...)

        return requested, upgrades, nil</span>
}

// handleBlockedEdges will check for the starting version in the current channel
// if it does not exist the version is blocked.
func handleBlockedEdges(ctx context.Context, c Client, arch, targetChannel string, startVer semver.Version) (bool, error) <span class="cov8" title="1">{
        chanVersions, err := GetVersions(ctx, c, arch, targetChannel)
        if err != nil </span><span class="cov0" title="0">{
                return true, err
        }</span>
        <span class="cov8" title="1">for _, v := range chanVersions </span><span class="cov8" title="1">{
                if v.EQ(startVer) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

// getSemverFromChannel will return the major and minor version from the source and target channels. The prefix returned is
// for the source channels for cross channel calculations.
func getSemverFromChannels(sourceChannel, targetChannel string) (source, target semver.Version, prefix string, err error) <span class="cov8" title="1">{
        // Get semver representation of source and target channel versions
        sourceIdx := strings.LastIndex(sourceChannel, "-")
        if sourceIdx == -1 </span><span class="cov0" title="0">{
                return source, target, prefix, fmt.Errorf("invalid channel name %s", sourceChannel)
        }</span>
        <span class="cov8" title="1">targetIdx := strings.LastIndex(targetChannel, "-")
        if targetIdx == -1 </span><span class="cov8" title="1">{
                return source, target, prefix, fmt.Errorf("invalid channel name %s", targetChannel)
        }</span>
        <span class="cov8" title="1">source, err = semver.Parse(fmt.Sprintf("%s.0", sourceChannel[sourceIdx+1:]))
        if err != nil </span><span class="cov0" title="0">{
                return source, target, prefix, err
        }</span>
        <span class="cov8" title="1">target, err = semver.Parse(fmt.Sprintf("%s.0", targetChannel[targetIdx+1:]))
        if err != nil </span><span class="cov0" title="0">{
                return source, target, prefix, err
        }</span>
        <span class="cov8" title="1">prefix = sourceChannel[:sourceIdx]
        return source, target, prefix, nil</span>
}

// GetChannelMinOrMax fetches the minimum or maximum version from the specified
// upstream Cincinnati stack given architecture and channel.
func GetChannelMinOrMax(ctx context.Context, c Client, arch string, channel string, min bool) (semver.Version, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return semver.Version{}, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf(ChannelInfo, channel, err),
                        cause:   err,
                }
        }</span>

        // Find the all versions within the graph.
        <span class="cov8" title="1">var versionMatcher *regexp.Regexp
        if versionFilter := os.Getenv("VERSION_FILTER"); len(versionFilter) != 0 </span><span class="cov0" title="0">{
                klog.Info("Usage of the VERSION_FILTER environment variable is unsupported")
                versionMatcher, err = regexp.Compile(versionFilter)
                if err != nil </span><span class="cov0" title="0">{
                        return semver.Version{}, &amp;Error{
                                Reason:  "InvalidVersionFilter",
                                Message: fmt.Sprintf("Version filter '%s' is not a valid regular expression", versionFilter),
                                cause:   err,
                        }
                }</span>
        }

        <span class="cov8" title="1">var Vers []semver.Version
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{
                if versionMatcher == nil || versionMatcher.MatchString(node.Version.String()) </span><span class="cov8" title="1">{
                        Vers = append(Vers, node.Version)
                }</span>
        }

        <span class="cov8" title="1">semver.Sort(Vers)

        if len(Vers) == 0 </span><span class="cov8" title="1">{
                return semver.Version{}, &amp;Error{
                        Reason:  "NoVersionsFound",
                        Message: fmt.Sprintf("no cluster versions found for %q in the %q channel", arch, channel),
                }
        }</span>

        <span class="cov8" title="1">if min </span><span class="cov8" title="1">{
                return Vers[0], nil
        }</span>

        <span class="cov8" title="1">return Vers[len(Vers)-1], nil</span>
}

// GetChannels fetches the channels containing update payloads from the specified
// upstream Cincinnati stack.
func GetChannels(ctx context.Context, c Client, channel string) (map[string]struct{}, error) <span class="cov0" title="0">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams("", channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf(ChannelInfo, channel, err),
                        cause:   err,
                }
        }</span>

        <span class="cov0" title="0">channels := make(map[string]struct{})

        for _, node := range graph.Nodes </span><span class="cov0" title="0">{
                values := node.Metadata["io.openshift.upgrades.graph.release.channels"]

                for _, value := range strings.Split(values, ",") </span><span class="cov0" title="0">{
                        channels[value] = struct{}{}
                }</span>
        }

        <span class="cov0" title="0">return channels, nil</span>
}

// GetVersions will return all update payloads from the specified
// upstream Cincinnati stack given architecture and channel.
func GetVersions(ctx context.Context, c Client, arch, channel string) ([]semver.Version, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf(ChannelInfo, channel, err),
                        cause:   err,
                }
        }</span>
        // Find the all versions within the graph.
        <span class="cov8" title="1">var Vers []semver.Version
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{

                Vers = append(Vers, node.Version)
        }</span>

        <span class="cov8" title="1">if len(Vers) == 0 </span><span class="cov8" title="1">{
                return nil, &amp;Error{
                        Reason:  "NoVersionsFound",
                        Message: fmt.Sprintf("no cluster versions found in the %q channel", channel),
                }
        }</span>

        <span class="cov8" title="1">semver.Sort(Vers)

        return Vers, nil</span>
}

// GetUpdatesInRange will return all update payload within a semver range for a specified channel and architecture.
func GetUpdatesInRange(ctx context.Context, c Client, channel, arch string, updateRange semver.Range) ([]Update, error) <span class="cov8" title="1">{
        // Prepare parametrized cincinnati query.
        c.SetQueryParams(arch, channel, "")

        graph, err := getGraphData(ctx, c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Reason:  "APIRequestError",
                        Message: fmt.Sprintf(ChannelInfo, channel, err),
                        cause:   err,
                }
        }</span>

        // Find the all updates within the range
        <span class="cov8" title="1">var updates []Update
        for _, node := range graph.Nodes </span><span class="cov8" title="1">{
                if updateRange(node.Version) </span><span class="cov8" title="1">{
                        updates = append(updates, Update(node))
                }</span>

        }
        <span class="cov8" title="1">return updates, nil</span>
}

// getGraphData fetches the update graph from the upstream Cincinnati stack given the current version and channel
func getGraphData(ctx context.Context, c Client) (graph graph, err error) <span class="cov8" title="1">{
        transport := c.GetTransport()
        uri := c.GetURL()
        // Download the update graph.
        req, err := http.NewRequest("GET", uri.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "InvalidRequest", Message: err.Error(), cause: err}
        }</span>
        <span class="cov8" title="1">req.Header.Add("Accept", GraphMediaType)
        if transport != nil &amp;&amp; transport.TLSClientConfig != nil </span><span class="cov8" title="1">{
                if c.GetTransport().TLSClientConfig.ClientCAs == nil </span><span class="cov8" title="1">{
                        klog.V(5).Infof("Using a root CA pool with 0 root CA subjects to request updates from %s", uri)
                }</span> //else {
                //klog.V(5).Infof("Using a root CA pool with %n root CA subjects to request updates from %s", len(transport.TLSClientConfig.RootCAs.Subjects()), uri)
                //}
        }

        <span class="cov8" title="1">if transport != nil &amp;&amp; transport.Proxy != nil </span><span class="cov8" title="1">{
                proxy, err := transport.Proxy(req)
                if err == nil &amp;&amp; proxy != nil </span><span class="cov0" title="0">{
                        klog.Infof("Using proxy %s to request updates from %s", proxy.Host, uri)
                }</span>
        }

        <span class="cov8" title="1">client := http.Client{}
        if transport != nil </span><span class="cov8" title="1">{
                client.Transport = transport
        }</span>
        <span class="cov8" title="1">timeoutCtx, cancel := context.WithTimeout(ctx, getUpdatesTimeout)
        defer cancel()
        resp, err := client.Do(req.WithContext(timeoutCtx))
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "RemoteFailed", Message: err.Error(), cause: err}
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseFailed", Message: fmt.Sprintf("unexpected HTTP status: %s", resp.Status)}
        }</span>

        // Parse the graph.
        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseFailed", Message: err.Error(), cause: err}
        }</span>

        <span class="cov8" title="1">if err = json.Unmarshal(body, &amp;graph); err != nil </span><span class="cov0" title="0">{
                return graph, &amp;Error{Reason: "ResponseInvalid", Message: err.Error(), cause: err}
        }</span>

        <span class="cov8" title="1">return graph, nil</span>
}

type graph struct {
        Nodes []node
        Edges []edge
}

type node struct {
        Version  semver.Version    `json:"version"`
        Image    string            `json:"payload"`
        Metadata map[string]string `json:"metadata,omitempty"`
}

type edge struct {
        Origin      int
        Destination int
}

// UnmarshalJSON unmarshals an edge in the update graph. The edge's JSON
// representation is a two-element array of indices, but Go's representation is
// a struct with two elements so this custom unmarshal method is required.
func (e *edge) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var fields []int
        if err := json.Unmarshal(data, &amp;fields); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(fields) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("expected 2 fields, found %d", len(fields))
        }</span>

        <span class="cov8" title="1">e.Origin = fields[0]
        e.Destination = fields[1]

        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package release

import (
        "errors"
        "sort"

        "github.com/blang/semver/v4"
        "github.com/lmzuccarelli/golang-oci-mirror/pkg/api/v1alpha2"
)

// ErrNoPreviousRelease is returned when no releases can be found in the
// release channels.
var ErrNoPreviousRelease = errors.New("no previous release downloads detected")

// FindRelease will find the minimum or maximum release for a set of ReleaseChannels
func FindRelease(channels []v1alpha2.ReleaseChannel, min bool) (string, semver.Version, error) <span class="cov8" title="1">{
        vers, err := findReleases(channels, min)
        if err != nil </span><span class="cov8" title="1">{
                return "", semver.Version{}, err
        }</span>

        <span class="cov8" title="1">keys := make([]string, 0, len(vers))
        for k := range vers </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">if min </span><span class="cov8" title="1">{
                sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                        return vers[keys[i]].GT(vers[keys[j]])
                }</span>)
        } else<span class="cov8" title="1"> {
                sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                        return vers[keys[i]].LT(vers[keys[j]])
                }</span>)
        }

        <span class="cov8" title="1">return keys[len(keys)-1], vers[keys[len(keys)-1]], nil</span>
}

func findReleases(channels []v1alpha2.ReleaseChannel, min bool) (map[string]semver.Version, error) <span class="cov8" title="1">{
        vers := make(map[string]semver.Version, len(channels))
        if len(channels) == 0 </span><span class="cov8" title="1">{
                return vers, ErrNoPreviousRelease
        }</span>

        <span class="cov8" title="1">for _, ch := range channels </span><span class="cov8" title="1">{

                ver := ch.MaxVersion
                if min </span><span class="cov8" title="1">{
                        ver = ch.MinVersion
                }</span>
                <span class="cov8" title="1">parsedVer, err := semver.Parse(ver)
                if err != nil </span><span class="cov0" title="0">{
                        return vers, err
                }</span>
                <span class="cov8" title="1">vers[ch.Name] = parsedVer</span>
        }

        <span class="cov8" title="1">return vers, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
